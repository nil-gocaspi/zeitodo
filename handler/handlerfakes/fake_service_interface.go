// Code generated by counterfeiter. DO NOT EDIT.
package handlerfakes

import (
	"example-project/handler"
	"example-project/model"
	"sync"
	"time"

	"go.mongodb.org/mongo-driver/mongo"
)

type FakeServiceInterface struct {
	AuthenticateUserStub        func(string, string, string) (string, string, error)
	authenticateUserMutex       sync.RWMutex
	authenticateUserArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 string
	}
	authenticateUserReturns struct {
		result1 string
		result2 string
		result3 error
	}
	authenticateUserReturnsOnCall map[int]struct {
		result1 string
		result2 string
		result3 error
	}
	CalcultimeEntryStub        func(string) (map[string]float64, error)
	calcultimeEntryMutex       sync.RWMutex
	calcultimeEntryArgsForCall []struct {
		arg1 string
	}
	calcultimeEntryReturns struct {
		result1 map[string]float64
		result2 error
	}
	calcultimeEntryReturnsOnCall map[int]struct {
		result1 map[string]float64
		result2 error
	}
	CollideTimeEntryStub        func(model.TimeEntry, model.TimeEntry) bool
	collideTimeEntryMutex       sync.RWMutex
	collideTimeEntryArgsForCall []struct {
		arg1 model.TimeEntry
		arg2 model.TimeEntry
	}
	collideTimeEntryReturns struct {
		result1 bool
	}
	collideTimeEntryReturnsOnCall map[int]struct {
		result1 bool
	}
	CreatTimeEntriesStub        func(model.TimeEntry) (interface{}, error)
	creatTimeEntriesMutex       sync.RWMutex
	creatTimeEntriesArgsForCall []struct {
		arg1 model.TimeEntry
	}
	creatTimeEntriesReturns struct {
		result1 interface{}
		result2 error
	}
	creatTimeEntriesReturnsOnCall map[int]struct {
		result1 interface{}
		result2 error
	}
	CreateProposalsStub        func([]model.ProposalPayload, string) (interface{}, error)
	createProposalsMutex       sync.RWMutex
	createProposalsArgsForCall []struct {
		arg1 []model.ProposalPayload
		arg2 string
	}
	createProposalsReturns struct {
		result1 interface{}
		result2 error
	}
	createProposalsReturnsOnCall map[int]struct {
		result1 interface{}
		result2 error
	}
	CreateUserStub        func(model.UserSignupPayload) (interface{}, error)
	createUserMutex       sync.RWMutex
	createUserArgsForCall []struct {
		arg1 model.UserSignupPayload
	}
	createUserReturns struct {
		result1 interface{}
		result2 error
	}
	createUserReturnsOnCall map[int]struct {
		result1 interface{}
		result2 error
	}
	DeleteProposalsByIDStub        func(string, string) error
	deleteProposalsByIDMutex       sync.RWMutex
	deleteProposalsByIDArgsForCall []struct {
		arg1 string
		arg2 string
	}
	deleteProposalsByIDReturns struct {
		result1 error
	}
	deleteProposalsByIDReturnsOnCall map[int]struct {
		result1 error
	}
	DeleteTimeEntriesStub        func(string, time.Time) (interface{}, error)
	deleteTimeEntriesMutex       sync.RWMutex
	deleteTimeEntriesArgsForCall []struct {
		arg1 string
		arg2 time.Time
	}
	deleteTimeEntriesReturns struct {
		result1 interface{}
		result2 error
	}
	deleteTimeEntriesReturnsOnCall map[int]struct {
		result1 interface{}
		result2 error
	}
	DeleteUsersStub        func(string) (interface{}, error)
	deleteUsersMutex       sync.RWMutex
	deleteUsersArgsForCall []struct {
		arg1 string
	}
	deleteUsersReturns struct {
		result1 interface{}
		result2 error
	}
	deleteUsersReturnsOnCall map[int]struct {
		result1 interface{}
		result2 error
	}
	GetAllTimeEntriesStub        func() ([]model.TimeEntry, error)
	getAllTimeEntriesMutex       sync.RWMutex
	getAllTimeEntriesArgsForCall []struct {
	}
	getAllTimeEntriesReturns struct {
		result1 []model.TimeEntry
		result2 error
	}
	getAllTimeEntriesReturnsOnCall map[int]struct {
		result1 []model.TimeEntry
		result2 error
	}
	GetAllUserStub        func() ([]model.UserPayload, error)
	getAllUserMutex       sync.RWMutex
	getAllUserArgsForCall []struct {
	}
	getAllUserReturns struct {
		result1 []model.UserPayload
		result2 error
	}
	getAllUserReturnsOnCall map[int]struct {
		result1 []model.UserPayload
		result2 error
	}
	GetProposalsByIDStub        func(string) ([]model.Proposal, error)
	getProposalsByIDMutex       sync.RWMutex
	getProposalsByIDArgsForCall []struct {
		arg1 string
	}
	getProposalsByIDReturns struct {
		result1 []model.Proposal
		result2 error
	}
	getProposalsByIDReturnsOnCall map[int]struct {
		result1 []model.Proposal
		result2 error
	}
	GetTeamMembersByNameStub        func(string) (interface{}, error)
	getTeamMembersByNameMutex       sync.RWMutex
	getTeamMembersByNameArgsForCall []struct {
		arg1 string
	}
	getTeamMembersByNameReturns struct {
		result1 interface{}
		result2 error
	}
	getTeamMembersByNameReturnsOnCall map[int]struct {
		result1 interface{}
		result2 error
	}
	GetTeamMembersByUserIDStub        func(string) (interface{}, error)
	getTeamMembersByUserIDMutex       sync.RWMutex
	getTeamMembersByUserIDArgsForCall []struct {
		arg1 string
	}
	getTeamMembersByUserIDReturns struct {
		result1 interface{}
		result2 error
	}
	getTeamMembersByUserIDReturnsOnCall map[int]struct {
		result1 interface{}
		result2 error
	}
	GetTimeEntriesStub        func(string) []model.TimeEntry
	getTimeEntriesMutex       sync.RWMutex
	getTimeEntriesArgsForCall []struct {
		arg1 string
	}
	getTimeEntriesReturns struct {
		result1 []model.TimeEntry
	}
	getTimeEntriesReturnsOnCall map[int]struct {
		result1 []model.TimeEntry
	}
	GetUserByIDStub        func(string) (model.UserPayload, error)
	getUserByIDMutex       sync.RWMutex
	getUserByIDArgsForCall []struct {
		arg1 string
	}
	getUserByIDReturns struct {
		result1 model.UserPayload
		result2 error
	}
	getUserByIDReturnsOnCall map[int]struct {
		result1 model.UserPayload
		result2 error
	}
	LoginUserStub        func(string, string) (string, error)
	loginUserMutex       sync.RWMutex
	loginUserArgsForCall []struct {
		arg1 string
		arg2 string
	}
	loginUserReturns struct {
		result1 string
		result2 error
	}
	loginUserReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	RefreshTokenStub        func(string) (string, error)
	refreshTokenMutex       sync.RWMutex
	refreshTokenArgsForCall []struct {
		arg1 string
	}
	refreshTokenReturns struct {
		result1 string
		result2 error
	}
	refreshTokenReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	UpdateProposalByDateStub        func(model.Proposal, string) (*mongo.UpdateResult, error)
	updateProposalByDateMutex       sync.RWMutex
	updateProposalByDateArgsForCall []struct {
		arg1 model.Proposal
		arg2 string
	}
	updateProposalByDateReturns struct {
		result1 *mongo.UpdateResult
		result2 error
	}
	updateProposalByDateReturnsOnCall map[int]struct {
		result1 *mongo.UpdateResult
		result2 error
	}
	UpdateTimeEntriesStub        func(model.TimeEntry) (interface{}, error)
	updateTimeEntriesMutex       sync.RWMutex
	updateTimeEntriesArgsForCall []struct {
		arg1 model.TimeEntry
	}
	updateTimeEntriesReturns struct {
		result1 interface{}
		result2 error
	}
	updateTimeEntriesReturnsOnCall map[int]struct {
		result1 interface{}
		result2 error
	}
	UpdateUsersStub        func([]model.UpdateUserPayload, string, string) (interface{}, error)
	updateUsersMutex       sync.RWMutex
	updateUsersArgsForCall []struct {
		arg1 []model.UpdateUserPayload
		arg2 string
		arg3 string
	}
	updateUsersReturns struct {
		result1 interface{}
		result2 error
	}
	updateUsersReturnsOnCall map[int]struct {
		result1 interface{}
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeServiceInterface) AuthenticateUser(arg1 string, arg2 string, arg3 string) (string, string, error) {
	fake.authenticateUserMutex.Lock()
	ret, specificReturn := fake.authenticateUserReturnsOnCall[len(fake.authenticateUserArgsForCall)]
	fake.authenticateUserArgsForCall = append(fake.authenticateUserArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.AuthenticateUserStub
	fakeReturns := fake.authenticateUserReturns
	fake.recordInvocation("AuthenticateUser", []interface{}{arg1, arg2, arg3})
	fake.authenticateUserMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeServiceInterface) AuthenticateUserCallCount() int {
	fake.authenticateUserMutex.RLock()
	defer fake.authenticateUserMutex.RUnlock()
	return len(fake.authenticateUserArgsForCall)
}

func (fake *FakeServiceInterface) AuthenticateUserCalls(stub func(string, string, string) (string, string, error)) {
	fake.authenticateUserMutex.Lock()
	defer fake.authenticateUserMutex.Unlock()
	fake.AuthenticateUserStub = stub
}

func (fake *FakeServiceInterface) AuthenticateUserArgsForCall(i int) (string, string, string) {
	fake.authenticateUserMutex.RLock()
	defer fake.authenticateUserMutex.RUnlock()
	argsForCall := fake.authenticateUserArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeServiceInterface) AuthenticateUserReturns(result1 string, result2 string, result3 error) {
	fake.authenticateUserMutex.Lock()
	defer fake.authenticateUserMutex.Unlock()
	fake.AuthenticateUserStub = nil
	fake.authenticateUserReturns = struct {
		result1 string
		result2 string
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeServiceInterface) AuthenticateUserReturnsOnCall(i int, result1 string, result2 string, result3 error) {
	fake.authenticateUserMutex.Lock()
	defer fake.authenticateUserMutex.Unlock()
	fake.AuthenticateUserStub = nil
	if fake.authenticateUserReturnsOnCall == nil {
		fake.authenticateUserReturnsOnCall = make(map[int]struct {
			result1 string
			result2 string
			result3 error
		})
	}
	fake.authenticateUserReturnsOnCall[i] = struct {
		result1 string
		result2 string
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeServiceInterface) CalcultimeEntry(arg1 string) (map[string]float64, error) {
	fake.calcultimeEntryMutex.Lock()
	ret, specificReturn := fake.calcultimeEntryReturnsOnCall[len(fake.calcultimeEntryArgsForCall)]
	fake.calcultimeEntryArgsForCall = append(fake.calcultimeEntryArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.CalcultimeEntryStub
	fakeReturns := fake.calcultimeEntryReturns
	fake.recordInvocation("CalcultimeEntry", []interface{}{arg1})
	fake.calcultimeEntryMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeServiceInterface) CalcultimeEntryCallCount() int {
	fake.calcultimeEntryMutex.RLock()
	defer fake.calcultimeEntryMutex.RUnlock()
	return len(fake.calcultimeEntryArgsForCall)
}

func (fake *FakeServiceInterface) CalcultimeEntryCalls(stub func(string) (map[string]float64, error)) {
	fake.calcultimeEntryMutex.Lock()
	defer fake.calcultimeEntryMutex.Unlock()
	fake.CalcultimeEntryStub = stub
}

func (fake *FakeServiceInterface) CalcultimeEntryArgsForCall(i int) string {
	fake.calcultimeEntryMutex.RLock()
	defer fake.calcultimeEntryMutex.RUnlock()
	argsForCall := fake.calcultimeEntryArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeServiceInterface) CalcultimeEntryReturns(result1 map[string]float64, result2 error) {
	fake.calcultimeEntryMutex.Lock()
	defer fake.calcultimeEntryMutex.Unlock()
	fake.CalcultimeEntryStub = nil
	fake.calcultimeEntryReturns = struct {
		result1 map[string]float64
		result2 error
	}{result1, result2}
}

func (fake *FakeServiceInterface) CalcultimeEntryReturnsOnCall(i int, result1 map[string]float64, result2 error) {
	fake.calcultimeEntryMutex.Lock()
	defer fake.calcultimeEntryMutex.Unlock()
	fake.CalcultimeEntryStub = nil
	if fake.calcultimeEntryReturnsOnCall == nil {
		fake.calcultimeEntryReturnsOnCall = make(map[int]struct {
			result1 map[string]float64
			result2 error
		})
	}
	fake.calcultimeEntryReturnsOnCall[i] = struct {
		result1 map[string]float64
		result2 error
	}{result1, result2}
}

func (fake *FakeServiceInterface) CollideTimeEntry(arg1 model.TimeEntry, arg2 model.TimeEntry) bool {
	fake.collideTimeEntryMutex.Lock()
	ret, specificReturn := fake.collideTimeEntryReturnsOnCall[len(fake.collideTimeEntryArgsForCall)]
	fake.collideTimeEntryArgsForCall = append(fake.collideTimeEntryArgsForCall, struct {
		arg1 model.TimeEntry
		arg2 model.TimeEntry
	}{arg1, arg2})
	stub := fake.CollideTimeEntryStub
	fakeReturns := fake.collideTimeEntryReturns
	fake.recordInvocation("CollideTimeEntry", []interface{}{arg1, arg2})
	fake.collideTimeEntryMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeServiceInterface) CollideTimeEntryCallCount() int {
	fake.collideTimeEntryMutex.RLock()
	defer fake.collideTimeEntryMutex.RUnlock()
	return len(fake.collideTimeEntryArgsForCall)
}

func (fake *FakeServiceInterface) CollideTimeEntryCalls(stub func(model.TimeEntry, model.TimeEntry) bool) {
	fake.collideTimeEntryMutex.Lock()
	defer fake.collideTimeEntryMutex.Unlock()
	fake.CollideTimeEntryStub = stub
}

func (fake *FakeServiceInterface) CollideTimeEntryArgsForCall(i int) (model.TimeEntry, model.TimeEntry) {
	fake.collideTimeEntryMutex.RLock()
	defer fake.collideTimeEntryMutex.RUnlock()
	argsForCall := fake.collideTimeEntryArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeServiceInterface) CollideTimeEntryReturns(result1 bool) {
	fake.collideTimeEntryMutex.Lock()
	defer fake.collideTimeEntryMutex.Unlock()
	fake.CollideTimeEntryStub = nil
	fake.collideTimeEntryReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeServiceInterface) CollideTimeEntryReturnsOnCall(i int, result1 bool) {
	fake.collideTimeEntryMutex.Lock()
	defer fake.collideTimeEntryMutex.Unlock()
	fake.CollideTimeEntryStub = nil
	if fake.collideTimeEntryReturnsOnCall == nil {
		fake.collideTimeEntryReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.collideTimeEntryReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeServiceInterface) CreatTimeEntries(arg1 model.TimeEntry) (interface{}, error) {
	fake.creatTimeEntriesMutex.Lock()
	ret, specificReturn := fake.creatTimeEntriesReturnsOnCall[len(fake.creatTimeEntriesArgsForCall)]
	fake.creatTimeEntriesArgsForCall = append(fake.creatTimeEntriesArgsForCall, struct {
		arg1 model.TimeEntry
	}{arg1})
	stub := fake.CreatTimeEntriesStub
	fakeReturns := fake.creatTimeEntriesReturns
	fake.recordInvocation("CreatTimeEntries", []interface{}{arg1})
	fake.creatTimeEntriesMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeServiceInterface) CreatTimeEntriesCallCount() int {
	fake.creatTimeEntriesMutex.RLock()
	defer fake.creatTimeEntriesMutex.RUnlock()
	return len(fake.creatTimeEntriesArgsForCall)
}

func (fake *FakeServiceInterface) CreatTimeEntriesCalls(stub func(model.TimeEntry) (interface{}, error)) {
	fake.creatTimeEntriesMutex.Lock()
	defer fake.creatTimeEntriesMutex.Unlock()
	fake.CreatTimeEntriesStub = stub
}

func (fake *FakeServiceInterface) CreatTimeEntriesArgsForCall(i int) model.TimeEntry {
	fake.creatTimeEntriesMutex.RLock()
	defer fake.creatTimeEntriesMutex.RUnlock()
	argsForCall := fake.creatTimeEntriesArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeServiceInterface) CreatTimeEntriesReturns(result1 interface{}, result2 error) {
	fake.creatTimeEntriesMutex.Lock()
	defer fake.creatTimeEntriesMutex.Unlock()
	fake.CreatTimeEntriesStub = nil
	fake.creatTimeEntriesReturns = struct {
		result1 interface{}
		result2 error
	}{result1, result2}
}

func (fake *FakeServiceInterface) CreatTimeEntriesReturnsOnCall(i int, result1 interface{}, result2 error) {
	fake.creatTimeEntriesMutex.Lock()
	defer fake.creatTimeEntriesMutex.Unlock()
	fake.CreatTimeEntriesStub = nil
	if fake.creatTimeEntriesReturnsOnCall == nil {
		fake.creatTimeEntriesReturnsOnCall = make(map[int]struct {
			result1 interface{}
			result2 error
		})
	}
	fake.creatTimeEntriesReturnsOnCall[i] = struct {
		result1 interface{}
		result2 error
	}{result1, result2}
}

func (fake *FakeServiceInterface) CreateProposals(arg1 []model.ProposalPayload, arg2 string) (interface{}, error) {
	var arg1Copy []model.ProposalPayload
	if arg1 != nil {
		arg1Copy = make([]model.ProposalPayload, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.createProposalsMutex.Lock()
	ret, specificReturn := fake.createProposalsReturnsOnCall[len(fake.createProposalsArgsForCall)]
	fake.createProposalsArgsForCall = append(fake.createProposalsArgsForCall, struct {
		arg1 []model.ProposalPayload
		arg2 string
	}{arg1Copy, arg2})
	stub := fake.CreateProposalsStub
	fakeReturns := fake.createProposalsReturns
	fake.recordInvocation("CreateProposals", []interface{}{arg1Copy, arg2})
	fake.createProposalsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeServiceInterface) CreateProposalsCallCount() int {
	fake.createProposalsMutex.RLock()
	defer fake.createProposalsMutex.RUnlock()
	return len(fake.createProposalsArgsForCall)
}

func (fake *FakeServiceInterface) CreateProposalsCalls(stub func([]model.ProposalPayload, string) (interface{}, error)) {
	fake.createProposalsMutex.Lock()
	defer fake.createProposalsMutex.Unlock()
	fake.CreateProposalsStub = stub
}

func (fake *FakeServiceInterface) CreateProposalsArgsForCall(i int) ([]model.ProposalPayload, string) {
	fake.createProposalsMutex.RLock()
	defer fake.createProposalsMutex.RUnlock()
	argsForCall := fake.createProposalsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeServiceInterface) CreateProposalsReturns(result1 interface{}, result2 error) {
	fake.createProposalsMutex.Lock()
	defer fake.createProposalsMutex.Unlock()
	fake.CreateProposalsStub = nil
	fake.createProposalsReturns = struct {
		result1 interface{}
		result2 error
	}{result1, result2}
}

func (fake *FakeServiceInterface) CreateProposalsReturnsOnCall(i int, result1 interface{}, result2 error) {
	fake.createProposalsMutex.Lock()
	defer fake.createProposalsMutex.Unlock()
	fake.CreateProposalsStub = nil
	if fake.createProposalsReturnsOnCall == nil {
		fake.createProposalsReturnsOnCall = make(map[int]struct {
			result1 interface{}
			result2 error
		})
	}
	fake.createProposalsReturnsOnCall[i] = struct {
		result1 interface{}
		result2 error
	}{result1, result2}
}

func (fake *FakeServiceInterface) CreateUser(arg1 model.UserSignupPayload) (interface{}, error) {
	fake.createUserMutex.Lock()
	ret, specificReturn := fake.createUserReturnsOnCall[len(fake.createUserArgsForCall)]
	fake.createUserArgsForCall = append(fake.createUserArgsForCall, struct {
		arg1 model.UserSignupPayload
	}{arg1})
	stub := fake.CreateUserStub
	fakeReturns := fake.createUserReturns
	fake.recordInvocation("CreateUser", []interface{}{arg1})
	fake.createUserMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeServiceInterface) CreateUserCallCount() int {
	fake.createUserMutex.RLock()
	defer fake.createUserMutex.RUnlock()
	return len(fake.createUserArgsForCall)
}

func (fake *FakeServiceInterface) CreateUserCalls(stub func(model.UserSignupPayload) (interface{}, error)) {
	fake.createUserMutex.Lock()
	defer fake.createUserMutex.Unlock()
	fake.CreateUserStub = stub
}

func (fake *FakeServiceInterface) CreateUserArgsForCall(i int) model.UserSignupPayload {
	fake.createUserMutex.RLock()
	defer fake.createUserMutex.RUnlock()
	argsForCall := fake.createUserArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeServiceInterface) CreateUserReturns(result1 interface{}, result2 error) {
	fake.createUserMutex.Lock()
	defer fake.createUserMutex.Unlock()
	fake.CreateUserStub = nil
	fake.createUserReturns = struct {
		result1 interface{}
		result2 error
	}{result1, result2}
}

func (fake *FakeServiceInterface) CreateUserReturnsOnCall(i int, result1 interface{}, result2 error) {
	fake.createUserMutex.Lock()
	defer fake.createUserMutex.Unlock()
	fake.CreateUserStub = nil
	if fake.createUserReturnsOnCall == nil {
		fake.createUserReturnsOnCall = make(map[int]struct {
			result1 interface{}
			result2 error
		})
	}
	fake.createUserReturnsOnCall[i] = struct {
		result1 interface{}
		result2 error
	}{result1, result2}
}

func (fake *FakeServiceInterface) DeleteProposalsByID(arg1 string, arg2 string) error {
	fake.deleteProposalsByIDMutex.Lock()
	ret, specificReturn := fake.deleteProposalsByIDReturnsOnCall[len(fake.deleteProposalsByIDArgsForCall)]
	fake.deleteProposalsByIDArgsForCall = append(fake.deleteProposalsByIDArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.DeleteProposalsByIDStub
	fakeReturns := fake.deleteProposalsByIDReturns
	fake.recordInvocation("DeleteProposalsByID", []interface{}{arg1, arg2})
	fake.deleteProposalsByIDMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeServiceInterface) DeleteProposalsByIDCallCount() int {
	fake.deleteProposalsByIDMutex.RLock()
	defer fake.deleteProposalsByIDMutex.RUnlock()
	return len(fake.deleteProposalsByIDArgsForCall)
}

func (fake *FakeServiceInterface) DeleteProposalsByIDCalls(stub func(string, string) error) {
	fake.deleteProposalsByIDMutex.Lock()
	defer fake.deleteProposalsByIDMutex.Unlock()
	fake.DeleteProposalsByIDStub = stub
}

func (fake *FakeServiceInterface) DeleteProposalsByIDArgsForCall(i int) (string, string) {
	fake.deleteProposalsByIDMutex.RLock()
	defer fake.deleteProposalsByIDMutex.RUnlock()
	argsForCall := fake.deleteProposalsByIDArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeServiceInterface) DeleteProposalsByIDReturns(result1 error) {
	fake.deleteProposalsByIDMutex.Lock()
	defer fake.deleteProposalsByIDMutex.Unlock()
	fake.DeleteProposalsByIDStub = nil
	fake.deleteProposalsByIDReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeServiceInterface) DeleteProposalsByIDReturnsOnCall(i int, result1 error) {
	fake.deleteProposalsByIDMutex.Lock()
	defer fake.deleteProposalsByIDMutex.Unlock()
	fake.DeleteProposalsByIDStub = nil
	if fake.deleteProposalsByIDReturnsOnCall == nil {
		fake.deleteProposalsByIDReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteProposalsByIDReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeServiceInterface) DeleteTimeEntries(arg1 string, arg2 time.Time) (interface{}, error) {
	fake.deleteTimeEntriesMutex.Lock()
	ret, specificReturn := fake.deleteTimeEntriesReturnsOnCall[len(fake.deleteTimeEntriesArgsForCall)]
	fake.deleteTimeEntriesArgsForCall = append(fake.deleteTimeEntriesArgsForCall, struct {
		arg1 string
		arg2 time.Time
	}{arg1, arg2})
	stub := fake.DeleteTimeEntriesStub
	fakeReturns := fake.deleteTimeEntriesReturns
	fake.recordInvocation("DeleteTimeEntries", []interface{}{arg1, arg2})
	fake.deleteTimeEntriesMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeServiceInterface) DeleteTimeEntriesCallCount() int {
	fake.deleteTimeEntriesMutex.RLock()
	defer fake.deleteTimeEntriesMutex.RUnlock()
	return len(fake.deleteTimeEntriesArgsForCall)
}

func (fake *FakeServiceInterface) DeleteTimeEntriesCalls(stub func(string, time.Time) (interface{}, error)) {
	fake.deleteTimeEntriesMutex.Lock()
	defer fake.deleteTimeEntriesMutex.Unlock()
	fake.DeleteTimeEntriesStub = stub
}

func (fake *FakeServiceInterface) DeleteTimeEntriesArgsForCall(i int) (string, time.Time) {
	fake.deleteTimeEntriesMutex.RLock()
	defer fake.deleteTimeEntriesMutex.RUnlock()
	argsForCall := fake.deleteTimeEntriesArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeServiceInterface) DeleteTimeEntriesReturns(result1 interface{}, result2 error) {
	fake.deleteTimeEntriesMutex.Lock()
	defer fake.deleteTimeEntriesMutex.Unlock()
	fake.DeleteTimeEntriesStub = nil
	fake.deleteTimeEntriesReturns = struct {
		result1 interface{}
		result2 error
	}{result1, result2}
}

func (fake *FakeServiceInterface) DeleteTimeEntriesReturnsOnCall(i int, result1 interface{}, result2 error) {
	fake.deleteTimeEntriesMutex.Lock()
	defer fake.deleteTimeEntriesMutex.Unlock()
	fake.DeleteTimeEntriesStub = nil
	if fake.deleteTimeEntriesReturnsOnCall == nil {
		fake.deleteTimeEntriesReturnsOnCall = make(map[int]struct {
			result1 interface{}
			result2 error
		})
	}
	fake.deleteTimeEntriesReturnsOnCall[i] = struct {
		result1 interface{}
		result2 error
	}{result1, result2}
}

func (fake *FakeServiceInterface) DeleteUsers(arg1 string) (interface{}, error) {
	fake.deleteUsersMutex.Lock()
	ret, specificReturn := fake.deleteUsersReturnsOnCall[len(fake.deleteUsersArgsForCall)]
	fake.deleteUsersArgsForCall = append(fake.deleteUsersArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.DeleteUsersStub
	fakeReturns := fake.deleteUsersReturns
	fake.recordInvocation("DeleteUsers", []interface{}{arg1})
	fake.deleteUsersMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeServiceInterface) DeleteUsersCallCount() int {
	fake.deleteUsersMutex.RLock()
	defer fake.deleteUsersMutex.RUnlock()
	return len(fake.deleteUsersArgsForCall)
}

func (fake *FakeServiceInterface) DeleteUsersCalls(stub func(string) (interface{}, error)) {
	fake.deleteUsersMutex.Lock()
	defer fake.deleteUsersMutex.Unlock()
	fake.DeleteUsersStub = stub
}

func (fake *FakeServiceInterface) DeleteUsersArgsForCall(i int) string {
	fake.deleteUsersMutex.RLock()
	defer fake.deleteUsersMutex.RUnlock()
	argsForCall := fake.deleteUsersArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeServiceInterface) DeleteUsersReturns(result1 interface{}, result2 error) {
	fake.deleteUsersMutex.Lock()
	defer fake.deleteUsersMutex.Unlock()
	fake.DeleteUsersStub = nil
	fake.deleteUsersReturns = struct {
		result1 interface{}
		result2 error
	}{result1, result2}
}

func (fake *FakeServiceInterface) DeleteUsersReturnsOnCall(i int, result1 interface{}, result2 error) {
	fake.deleteUsersMutex.Lock()
	defer fake.deleteUsersMutex.Unlock()
	fake.DeleteUsersStub = nil
	if fake.deleteUsersReturnsOnCall == nil {
		fake.deleteUsersReturnsOnCall = make(map[int]struct {
			result1 interface{}
			result2 error
		})
	}
	fake.deleteUsersReturnsOnCall[i] = struct {
		result1 interface{}
		result2 error
	}{result1, result2}
}

func (fake *FakeServiceInterface) GetAllTimeEntries() ([]model.TimeEntry, error) {
	fake.getAllTimeEntriesMutex.Lock()
	ret, specificReturn := fake.getAllTimeEntriesReturnsOnCall[len(fake.getAllTimeEntriesArgsForCall)]
	fake.getAllTimeEntriesArgsForCall = append(fake.getAllTimeEntriesArgsForCall, struct {
	}{})
	stub := fake.GetAllTimeEntriesStub
	fakeReturns := fake.getAllTimeEntriesReturns
	fake.recordInvocation("GetAllTimeEntries", []interface{}{})
	fake.getAllTimeEntriesMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeServiceInterface) GetAllTimeEntriesCallCount() int {
	fake.getAllTimeEntriesMutex.RLock()
	defer fake.getAllTimeEntriesMutex.RUnlock()
	return len(fake.getAllTimeEntriesArgsForCall)
}

func (fake *FakeServiceInterface) GetAllTimeEntriesCalls(stub func() ([]model.TimeEntry, error)) {
	fake.getAllTimeEntriesMutex.Lock()
	defer fake.getAllTimeEntriesMutex.Unlock()
	fake.GetAllTimeEntriesStub = stub
}

func (fake *FakeServiceInterface) GetAllTimeEntriesReturns(result1 []model.TimeEntry, result2 error) {
	fake.getAllTimeEntriesMutex.Lock()
	defer fake.getAllTimeEntriesMutex.Unlock()
	fake.GetAllTimeEntriesStub = nil
	fake.getAllTimeEntriesReturns = struct {
		result1 []model.TimeEntry
		result2 error
	}{result1, result2}
}

func (fake *FakeServiceInterface) GetAllTimeEntriesReturnsOnCall(i int, result1 []model.TimeEntry, result2 error) {
	fake.getAllTimeEntriesMutex.Lock()
	defer fake.getAllTimeEntriesMutex.Unlock()
	fake.GetAllTimeEntriesStub = nil
	if fake.getAllTimeEntriesReturnsOnCall == nil {
		fake.getAllTimeEntriesReturnsOnCall = make(map[int]struct {
			result1 []model.TimeEntry
			result2 error
		})
	}
	fake.getAllTimeEntriesReturnsOnCall[i] = struct {
		result1 []model.TimeEntry
		result2 error
	}{result1, result2}
}

func (fake *FakeServiceInterface) GetAllUser() ([]model.UserPayload, error) {
	fake.getAllUserMutex.Lock()
	ret, specificReturn := fake.getAllUserReturnsOnCall[len(fake.getAllUserArgsForCall)]
	fake.getAllUserArgsForCall = append(fake.getAllUserArgsForCall, struct {
	}{})
	stub := fake.GetAllUserStub
	fakeReturns := fake.getAllUserReturns
	fake.recordInvocation("GetAllUser", []interface{}{})
	fake.getAllUserMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeServiceInterface) GetAllUserCallCount() int {
	fake.getAllUserMutex.RLock()
	defer fake.getAllUserMutex.RUnlock()
	return len(fake.getAllUserArgsForCall)
}

func (fake *FakeServiceInterface) GetAllUserCalls(stub func() ([]model.UserPayload, error)) {
	fake.getAllUserMutex.Lock()
	defer fake.getAllUserMutex.Unlock()
	fake.GetAllUserStub = stub
}

func (fake *FakeServiceInterface) GetAllUserReturns(result1 []model.UserPayload, result2 error) {
	fake.getAllUserMutex.Lock()
	defer fake.getAllUserMutex.Unlock()
	fake.GetAllUserStub = nil
	fake.getAllUserReturns = struct {
		result1 []model.UserPayload
		result2 error
	}{result1, result2}
}

func (fake *FakeServiceInterface) GetAllUserReturnsOnCall(i int, result1 []model.UserPayload, result2 error) {
	fake.getAllUserMutex.Lock()
	defer fake.getAllUserMutex.Unlock()
	fake.GetAllUserStub = nil
	if fake.getAllUserReturnsOnCall == nil {
		fake.getAllUserReturnsOnCall = make(map[int]struct {
			result1 []model.UserPayload
			result2 error
		})
	}
	fake.getAllUserReturnsOnCall[i] = struct {
		result1 []model.UserPayload
		result2 error
	}{result1, result2}
}

func (fake *FakeServiceInterface) GetProposalsByID(arg1 string) ([]model.Proposal, error) {
	fake.getProposalsByIDMutex.Lock()
	ret, specificReturn := fake.getProposalsByIDReturnsOnCall[len(fake.getProposalsByIDArgsForCall)]
	fake.getProposalsByIDArgsForCall = append(fake.getProposalsByIDArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.GetProposalsByIDStub
	fakeReturns := fake.getProposalsByIDReturns
	fake.recordInvocation("GetProposalsByID", []interface{}{arg1})
	fake.getProposalsByIDMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeServiceInterface) GetProposalsByIDCallCount() int {
	fake.getProposalsByIDMutex.RLock()
	defer fake.getProposalsByIDMutex.RUnlock()
	return len(fake.getProposalsByIDArgsForCall)
}

func (fake *FakeServiceInterface) GetProposalsByIDCalls(stub func(string) ([]model.Proposal, error)) {
	fake.getProposalsByIDMutex.Lock()
	defer fake.getProposalsByIDMutex.Unlock()
	fake.GetProposalsByIDStub = stub
}

func (fake *FakeServiceInterface) GetProposalsByIDArgsForCall(i int) string {
	fake.getProposalsByIDMutex.RLock()
	defer fake.getProposalsByIDMutex.RUnlock()
	argsForCall := fake.getProposalsByIDArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeServiceInterface) GetProposalsByIDReturns(result1 []model.Proposal, result2 error) {
	fake.getProposalsByIDMutex.Lock()
	defer fake.getProposalsByIDMutex.Unlock()
	fake.GetProposalsByIDStub = nil
	fake.getProposalsByIDReturns = struct {
		result1 []model.Proposal
		result2 error
	}{result1, result2}
}

func (fake *FakeServiceInterface) GetProposalsByIDReturnsOnCall(i int, result1 []model.Proposal, result2 error) {
	fake.getProposalsByIDMutex.Lock()
	defer fake.getProposalsByIDMutex.Unlock()
	fake.GetProposalsByIDStub = nil
	if fake.getProposalsByIDReturnsOnCall == nil {
		fake.getProposalsByIDReturnsOnCall = make(map[int]struct {
			result1 []model.Proposal
			result2 error
		})
	}
	fake.getProposalsByIDReturnsOnCall[i] = struct {
		result1 []model.Proposal
		result2 error
	}{result1, result2}
}

func (fake *FakeServiceInterface) GetTeamMembersByName(arg1 string) (interface{}, error) {
	fake.getTeamMembersByNameMutex.Lock()
	ret, specificReturn := fake.getTeamMembersByNameReturnsOnCall[len(fake.getTeamMembersByNameArgsForCall)]
	fake.getTeamMembersByNameArgsForCall = append(fake.getTeamMembersByNameArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.GetTeamMembersByNameStub
	fakeReturns := fake.getTeamMembersByNameReturns
	fake.recordInvocation("GetTeamMembersByName", []interface{}{arg1})
	fake.getTeamMembersByNameMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeServiceInterface) GetTeamMembersByNameCallCount() int {
	fake.getTeamMembersByNameMutex.RLock()
	defer fake.getTeamMembersByNameMutex.RUnlock()
	return len(fake.getTeamMembersByNameArgsForCall)
}

func (fake *FakeServiceInterface) GetTeamMembersByNameCalls(stub func(string) (interface{}, error)) {
	fake.getTeamMembersByNameMutex.Lock()
	defer fake.getTeamMembersByNameMutex.Unlock()
	fake.GetTeamMembersByNameStub = stub
}

func (fake *FakeServiceInterface) GetTeamMembersByNameArgsForCall(i int) string {
	fake.getTeamMembersByNameMutex.RLock()
	defer fake.getTeamMembersByNameMutex.RUnlock()
	argsForCall := fake.getTeamMembersByNameArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeServiceInterface) GetTeamMembersByNameReturns(result1 interface{}, result2 error) {
	fake.getTeamMembersByNameMutex.Lock()
	defer fake.getTeamMembersByNameMutex.Unlock()
	fake.GetTeamMembersByNameStub = nil
	fake.getTeamMembersByNameReturns = struct {
		result1 interface{}
		result2 error
	}{result1, result2}
}

func (fake *FakeServiceInterface) GetTeamMembersByNameReturnsOnCall(i int, result1 interface{}, result2 error) {
	fake.getTeamMembersByNameMutex.Lock()
	defer fake.getTeamMembersByNameMutex.Unlock()
	fake.GetTeamMembersByNameStub = nil
	if fake.getTeamMembersByNameReturnsOnCall == nil {
		fake.getTeamMembersByNameReturnsOnCall = make(map[int]struct {
			result1 interface{}
			result2 error
		})
	}
	fake.getTeamMembersByNameReturnsOnCall[i] = struct {
		result1 interface{}
		result2 error
	}{result1, result2}
}

func (fake *FakeServiceInterface) GetTeamMembersByUserID(arg1 string) (interface{}, error) {
	fake.getTeamMembersByUserIDMutex.Lock()
	ret, specificReturn := fake.getTeamMembersByUserIDReturnsOnCall[len(fake.getTeamMembersByUserIDArgsForCall)]
	fake.getTeamMembersByUserIDArgsForCall = append(fake.getTeamMembersByUserIDArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.GetTeamMembersByUserIDStub
	fakeReturns := fake.getTeamMembersByUserIDReturns
	fake.recordInvocation("GetTeamMembersByUserID", []interface{}{arg1})
	fake.getTeamMembersByUserIDMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeServiceInterface) GetTeamMembersByUserIDCallCount() int {
	fake.getTeamMembersByUserIDMutex.RLock()
	defer fake.getTeamMembersByUserIDMutex.RUnlock()
	return len(fake.getTeamMembersByUserIDArgsForCall)
}

func (fake *FakeServiceInterface) GetTeamMembersByUserIDCalls(stub func(string) (interface{}, error)) {
	fake.getTeamMembersByUserIDMutex.Lock()
	defer fake.getTeamMembersByUserIDMutex.Unlock()
	fake.GetTeamMembersByUserIDStub = stub
}

func (fake *FakeServiceInterface) GetTeamMembersByUserIDArgsForCall(i int) string {
	fake.getTeamMembersByUserIDMutex.RLock()
	defer fake.getTeamMembersByUserIDMutex.RUnlock()
	argsForCall := fake.getTeamMembersByUserIDArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeServiceInterface) GetTeamMembersByUserIDReturns(result1 interface{}, result2 error) {
	fake.getTeamMembersByUserIDMutex.Lock()
	defer fake.getTeamMembersByUserIDMutex.Unlock()
	fake.GetTeamMembersByUserIDStub = nil
	fake.getTeamMembersByUserIDReturns = struct {
		result1 interface{}
		result2 error
	}{result1, result2}
}

func (fake *FakeServiceInterface) GetTeamMembersByUserIDReturnsOnCall(i int, result1 interface{}, result2 error) {
	fake.getTeamMembersByUserIDMutex.Lock()
	defer fake.getTeamMembersByUserIDMutex.Unlock()
	fake.GetTeamMembersByUserIDStub = nil
	if fake.getTeamMembersByUserIDReturnsOnCall == nil {
		fake.getTeamMembersByUserIDReturnsOnCall = make(map[int]struct {
			result1 interface{}
			result2 error
		})
	}
	fake.getTeamMembersByUserIDReturnsOnCall[i] = struct {
		result1 interface{}
		result2 error
	}{result1, result2}
}

func (fake *FakeServiceInterface) GetTimeEntries(arg1 string) []model.TimeEntry {
	fake.getTimeEntriesMutex.Lock()
	ret, specificReturn := fake.getTimeEntriesReturnsOnCall[len(fake.getTimeEntriesArgsForCall)]
	fake.getTimeEntriesArgsForCall = append(fake.getTimeEntriesArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.GetTimeEntriesStub
	fakeReturns := fake.getTimeEntriesReturns
	fake.recordInvocation("GetTimeEntries", []interface{}{arg1})
	fake.getTimeEntriesMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeServiceInterface) GetTimeEntriesCallCount() int {
	fake.getTimeEntriesMutex.RLock()
	defer fake.getTimeEntriesMutex.RUnlock()
	return len(fake.getTimeEntriesArgsForCall)
}

func (fake *FakeServiceInterface) GetTimeEntriesCalls(stub func(string) []model.TimeEntry) {
	fake.getTimeEntriesMutex.Lock()
	defer fake.getTimeEntriesMutex.Unlock()
	fake.GetTimeEntriesStub = stub
}

func (fake *FakeServiceInterface) GetTimeEntriesArgsForCall(i int) string {
	fake.getTimeEntriesMutex.RLock()
	defer fake.getTimeEntriesMutex.RUnlock()
	argsForCall := fake.getTimeEntriesArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeServiceInterface) GetTimeEntriesReturns(result1 []model.TimeEntry) {
	fake.getTimeEntriesMutex.Lock()
	defer fake.getTimeEntriesMutex.Unlock()
	fake.GetTimeEntriesStub = nil
	fake.getTimeEntriesReturns = struct {
		result1 []model.TimeEntry
	}{result1}
}

func (fake *FakeServiceInterface) GetTimeEntriesReturnsOnCall(i int, result1 []model.TimeEntry) {
	fake.getTimeEntriesMutex.Lock()
	defer fake.getTimeEntriesMutex.Unlock()
	fake.GetTimeEntriesStub = nil
	if fake.getTimeEntriesReturnsOnCall == nil {
		fake.getTimeEntriesReturnsOnCall = make(map[int]struct {
			result1 []model.TimeEntry
		})
	}
	fake.getTimeEntriesReturnsOnCall[i] = struct {
		result1 []model.TimeEntry
	}{result1}
}

func (fake *FakeServiceInterface) GetUserByID(arg1 string) (model.UserPayload, error) {
	fake.getUserByIDMutex.Lock()
	ret, specificReturn := fake.getUserByIDReturnsOnCall[len(fake.getUserByIDArgsForCall)]
	fake.getUserByIDArgsForCall = append(fake.getUserByIDArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.GetUserByIDStub
	fakeReturns := fake.getUserByIDReturns
	fake.recordInvocation("GetUserByID", []interface{}{arg1})
	fake.getUserByIDMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeServiceInterface) GetUserByIDCallCount() int {
	fake.getUserByIDMutex.RLock()
	defer fake.getUserByIDMutex.RUnlock()
	return len(fake.getUserByIDArgsForCall)
}

func (fake *FakeServiceInterface) GetUserByIDCalls(stub func(string) (model.UserPayload, error)) {
	fake.getUserByIDMutex.Lock()
	defer fake.getUserByIDMutex.Unlock()
	fake.GetUserByIDStub = stub
}

func (fake *FakeServiceInterface) GetUserByIDArgsForCall(i int) string {
	fake.getUserByIDMutex.RLock()
	defer fake.getUserByIDMutex.RUnlock()
	argsForCall := fake.getUserByIDArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeServiceInterface) GetUserByIDReturns(result1 model.UserPayload, result2 error) {
	fake.getUserByIDMutex.Lock()
	defer fake.getUserByIDMutex.Unlock()
	fake.GetUserByIDStub = nil
	fake.getUserByIDReturns = struct {
		result1 model.UserPayload
		result2 error
	}{result1, result2}
}

func (fake *FakeServiceInterface) GetUserByIDReturnsOnCall(i int, result1 model.UserPayload, result2 error) {
	fake.getUserByIDMutex.Lock()
	defer fake.getUserByIDMutex.Unlock()
	fake.GetUserByIDStub = nil
	if fake.getUserByIDReturnsOnCall == nil {
		fake.getUserByIDReturnsOnCall = make(map[int]struct {
			result1 model.UserPayload
			result2 error
		})
	}
	fake.getUserByIDReturnsOnCall[i] = struct {
		result1 model.UserPayload
		result2 error
	}{result1, result2}
}

func (fake *FakeServiceInterface) LoginUser(arg1 string, arg2 string) (string, error) {
	fake.loginUserMutex.Lock()
	ret, specificReturn := fake.loginUserReturnsOnCall[len(fake.loginUserArgsForCall)]
	fake.loginUserArgsForCall = append(fake.loginUserArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.LoginUserStub
	fakeReturns := fake.loginUserReturns
	fake.recordInvocation("LoginUser", []interface{}{arg1, arg2})
	fake.loginUserMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeServiceInterface) LoginUserCallCount() int {
	fake.loginUserMutex.RLock()
	defer fake.loginUserMutex.RUnlock()
	return len(fake.loginUserArgsForCall)
}

func (fake *FakeServiceInterface) LoginUserCalls(stub func(string, string) (string, error)) {
	fake.loginUserMutex.Lock()
	defer fake.loginUserMutex.Unlock()
	fake.LoginUserStub = stub
}

func (fake *FakeServiceInterface) LoginUserArgsForCall(i int) (string, string) {
	fake.loginUserMutex.RLock()
	defer fake.loginUserMutex.RUnlock()
	argsForCall := fake.loginUserArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeServiceInterface) LoginUserReturns(result1 string, result2 error) {
	fake.loginUserMutex.Lock()
	defer fake.loginUserMutex.Unlock()
	fake.LoginUserStub = nil
	fake.loginUserReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeServiceInterface) LoginUserReturnsOnCall(i int, result1 string, result2 error) {
	fake.loginUserMutex.Lock()
	defer fake.loginUserMutex.Unlock()
	fake.LoginUserStub = nil
	if fake.loginUserReturnsOnCall == nil {
		fake.loginUserReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.loginUserReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeServiceInterface) RefreshToken(arg1 string) (string, error) {
	fake.refreshTokenMutex.Lock()
	ret, specificReturn := fake.refreshTokenReturnsOnCall[len(fake.refreshTokenArgsForCall)]
	fake.refreshTokenArgsForCall = append(fake.refreshTokenArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.RefreshTokenStub
	fakeReturns := fake.refreshTokenReturns
	fake.recordInvocation("RefreshToken", []interface{}{arg1})
	fake.refreshTokenMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeServiceInterface) RefreshTokenCallCount() int {
	fake.refreshTokenMutex.RLock()
	defer fake.refreshTokenMutex.RUnlock()
	return len(fake.refreshTokenArgsForCall)
}

func (fake *FakeServiceInterface) RefreshTokenCalls(stub func(string) (string, error)) {
	fake.refreshTokenMutex.Lock()
	defer fake.refreshTokenMutex.Unlock()
	fake.RefreshTokenStub = stub
}

func (fake *FakeServiceInterface) RefreshTokenArgsForCall(i int) string {
	fake.refreshTokenMutex.RLock()
	defer fake.refreshTokenMutex.RUnlock()
	argsForCall := fake.refreshTokenArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeServiceInterface) RefreshTokenReturns(result1 string, result2 error) {
	fake.refreshTokenMutex.Lock()
	defer fake.refreshTokenMutex.Unlock()
	fake.RefreshTokenStub = nil
	fake.refreshTokenReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeServiceInterface) RefreshTokenReturnsOnCall(i int, result1 string, result2 error) {
	fake.refreshTokenMutex.Lock()
	defer fake.refreshTokenMutex.Unlock()
	fake.RefreshTokenStub = nil
	if fake.refreshTokenReturnsOnCall == nil {
		fake.refreshTokenReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.refreshTokenReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeServiceInterface) UpdateProposalByDate(arg1 model.Proposal, arg2 string) (*mongo.UpdateResult, error) {
	fake.updateProposalByDateMutex.Lock()
	ret, specificReturn := fake.updateProposalByDateReturnsOnCall[len(fake.updateProposalByDateArgsForCall)]
	fake.updateProposalByDateArgsForCall = append(fake.updateProposalByDateArgsForCall, struct {
		arg1 model.Proposal
		arg2 string
	}{arg1, arg2})
	stub := fake.UpdateProposalByDateStub
	fakeReturns := fake.updateProposalByDateReturns
	fake.recordInvocation("UpdateProposalByDate", []interface{}{arg1, arg2})
	fake.updateProposalByDateMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeServiceInterface) UpdateProposalByDateCallCount() int {
	fake.updateProposalByDateMutex.RLock()
	defer fake.updateProposalByDateMutex.RUnlock()
	return len(fake.updateProposalByDateArgsForCall)
}

func (fake *FakeServiceInterface) UpdateProposalByDateCalls(stub func(model.Proposal, string) (*mongo.UpdateResult, error)) {
	fake.updateProposalByDateMutex.Lock()
	defer fake.updateProposalByDateMutex.Unlock()
	fake.UpdateProposalByDateStub = stub
}

func (fake *FakeServiceInterface) UpdateProposalByDateArgsForCall(i int) (model.Proposal, string) {
	fake.updateProposalByDateMutex.RLock()
	defer fake.updateProposalByDateMutex.RUnlock()
	argsForCall := fake.updateProposalByDateArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeServiceInterface) UpdateProposalByDateReturns(result1 *mongo.UpdateResult, result2 error) {
	fake.updateProposalByDateMutex.Lock()
	defer fake.updateProposalByDateMutex.Unlock()
	fake.UpdateProposalByDateStub = nil
	fake.updateProposalByDateReturns = struct {
		result1 *mongo.UpdateResult
		result2 error
	}{result1, result2}
}

func (fake *FakeServiceInterface) UpdateProposalByDateReturnsOnCall(i int, result1 *mongo.UpdateResult, result2 error) {
	fake.updateProposalByDateMutex.Lock()
	defer fake.updateProposalByDateMutex.Unlock()
	fake.UpdateProposalByDateStub = nil
	if fake.updateProposalByDateReturnsOnCall == nil {
		fake.updateProposalByDateReturnsOnCall = make(map[int]struct {
			result1 *mongo.UpdateResult
			result2 error
		})
	}
	fake.updateProposalByDateReturnsOnCall[i] = struct {
		result1 *mongo.UpdateResult
		result2 error
	}{result1, result2}
}

func (fake *FakeServiceInterface) UpdateTimeEntries(arg1 model.TimeEntry) (interface{}, error) {
	fake.updateTimeEntriesMutex.Lock()
	ret, specificReturn := fake.updateTimeEntriesReturnsOnCall[len(fake.updateTimeEntriesArgsForCall)]
	fake.updateTimeEntriesArgsForCall = append(fake.updateTimeEntriesArgsForCall, struct {
		arg1 model.TimeEntry
	}{arg1})
	stub := fake.UpdateTimeEntriesStub
	fakeReturns := fake.updateTimeEntriesReturns
	fake.recordInvocation("UpdateTimeEntries", []interface{}{arg1})
	fake.updateTimeEntriesMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeServiceInterface) UpdateTimeEntriesCallCount() int {
	fake.updateTimeEntriesMutex.RLock()
	defer fake.updateTimeEntriesMutex.RUnlock()
	return len(fake.updateTimeEntriesArgsForCall)
}

func (fake *FakeServiceInterface) UpdateTimeEntriesCalls(stub func(model.TimeEntry) (interface{}, error)) {
	fake.updateTimeEntriesMutex.Lock()
	defer fake.updateTimeEntriesMutex.Unlock()
	fake.UpdateTimeEntriesStub = stub
}

func (fake *FakeServiceInterface) UpdateTimeEntriesArgsForCall(i int) model.TimeEntry {
	fake.updateTimeEntriesMutex.RLock()
	defer fake.updateTimeEntriesMutex.RUnlock()
	argsForCall := fake.updateTimeEntriesArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeServiceInterface) UpdateTimeEntriesReturns(result1 interface{}, result2 error) {
	fake.updateTimeEntriesMutex.Lock()
	defer fake.updateTimeEntriesMutex.Unlock()
	fake.UpdateTimeEntriesStub = nil
	fake.updateTimeEntriesReturns = struct {
		result1 interface{}
		result2 error
	}{result1, result2}
}

func (fake *FakeServiceInterface) UpdateTimeEntriesReturnsOnCall(i int, result1 interface{}, result2 error) {
	fake.updateTimeEntriesMutex.Lock()
	defer fake.updateTimeEntriesMutex.Unlock()
	fake.UpdateTimeEntriesStub = nil
	if fake.updateTimeEntriesReturnsOnCall == nil {
		fake.updateTimeEntriesReturnsOnCall = make(map[int]struct {
			result1 interface{}
			result2 error
		})
	}
	fake.updateTimeEntriesReturnsOnCall[i] = struct {
		result1 interface{}
		result2 error
	}{result1, result2}
}

func (fake *FakeServiceInterface) UpdateUsers(arg1 []model.UpdateUserPayload, arg2 string, arg3 string) (interface{}, error) {
	var arg1Copy []model.UpdateUserPayload
	if arg1 != nil {
		arg1Copy = make([]model.UpdateUserPayload, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.updateUsersMutex.Lock()
	ret, specificReturn := fake.updateUsersReturnsOnCall[len(fake.updateUsersArgsForCall)]
	fake.updateUsersArgsForCall = append(fake.updateUsersArgsForCall, struct {
		arg1 []model.UpdateUserPayload
		arg2 string
		arg3 string
	}{arg1Copy, arg2, arg3})
	stub := fake.UpdateUsersStub
	fakeReturns := fake.updateUsersReturns
	fake.recordInvocation("UpdateUsers", []interface{}{arg1Copy, arg2, arg3})
	fake.updateUsersMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeServiceInterface) UpdateUsersCallCount() int {
	fake.updateUsersMutex.RLock()
	defer fake.updateUsersMutex.RUnlock()
	return len(fake.updateUsersArgsForCall)
}

func (fake *FakeServiceInterface) UpdateUsersCalls(stub func([]model.UpdateUserPayload, string, string) (interface{}, error)) {
	fake.updateUsersMutex.Lock()
	defer fake.updateUsersMutex.Unlock()
	fake.UpdateUsersStub = stub
}

func (fake *FakeServiceInterface) UpdateUsersArgsForCall(i int) ([]model.UpdateUserPayload, string, string) {
	fake.updateUsersMutex.RLock()
	defer fake.updateUsersMutex.RUnlock()
	argsForCall := fake.updateUsersArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeServiceInterface) UpdateUsersReturns(result1 interface{}, result2 error) {
	fake.updateUsersMutex.Lock()
	defer fake.updateUsersMutex.Unlock()
	fake.UpdateUsersStub = nil
	fake.updateUsersReturns = struct {
		result1 interface{}
		result2 error
	}{result1, result2}
}

func (fake *FakeServiceInterface) UpdateUsersReturnsOnCall(i int, result1 interface{}, result2 error) {
	fake.updateUsersMutex.Lock()
	defer fake.updateUsersMutex.Unlock()
	fake.UpdateUsersStub = nil
	if fake.updateUsersReturnsOnCall == nil {
		fake.updateUsersReturnsOnCall = make(map[int]struct {
			result1 interface{}
			result2 error
		})
	}
	fake.updateUsersReturnsOnCall[i] = struct {
		result1 interface{}
		result2 error
	}{result1, result2}
}

func (fake *FakeServiceInterface) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.authenticateUserMutex.RLock()
	defer fake.authenticateUserMutex.RUnlock()
	fake.calcultimeEntryMutex.RLock()
	defer fake.calcultimeEntryMutex.RUnlock()
	fake.collideTimeEntryMutex.RLock()
	defer fake.collideTimeEntryMutex.RUnlock()
	fake.creatTimeEntriesMutex.RLock()
	defer fake.creatTimeEntriesMutex.RUnlock()
	fake.createProposalsMutex.RLock()
	defer fake.createProposalsMutex.RUnlock()
	fake.createUserMutex.RLock()
	defer fake.createUserMutex.RUnlock()
	fake.deleteProposalsByIDMutex.RLock()
	defer fake.deleteProposalsByIDMutex.RUnlock()
	fake.deleteTimeEntriesMutex.RLock()
	defer fake.deleteTimeEntriesMutex.RUnlock()
	fake.deleteUsersMutex.RLock()
	defer fake.deleteUsersMutex.RUnlock()
	fake.getAllTimeEntriesMutex.RLock()
	defer fake.getAllTimeEntriesMutex.RUnlock()
	fake.getAllUserMutex.RLock()
	defer fake.getAllUserMutex.RUnlock()
	fake.getProposalsByIDMutex.RLock()
	defer fake.getProposalsByIDMutex.RUnlock()
	fake.getTeamMembersByNameMutex.RLock()
	defer fake.getTeamMembersByNameMutex.RUnlock()
	fake.getTeamMembersByUserIDMutex.RLock()
	defer fake.getTeamMembersByUserIDMutex.RUnlock()
	fake.getTimeEntriesMutex.RLock()
	defer fake.getTimeEntriesMutex.RUnlock()
	fake.getUserByIDMutex.RLock()
	defer fake.getUserByIDMutex.RUnlock()
	fake.loginUserMutex.RLock()
	defer fake.loginUserMutex.RUnlock()
	fake.refreshTokenMutex.RLock()
	defer fake.refreshTokenMutex.RUnlock()
	fake.updateProposalByDateMutex.RLock()
	defer fake.updateProposalByDateMutex.RUnlock()
	fake.updateTimeEntriesMutex.RLock()
	defer fake.updateTimeEntriesMutex.RUnlock()
	fake.updateUsersMutex.RLock()
	defer fake.updateUsersMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeServiceInterface) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ handler.ServiceInterface = new(FakeServiceInterface)
