// Code generated by counterfeiter. DO NOT EDIT.
package servicefakes

import (
	"example-project/model"
	"example-project/service"
	"sync"
	"time"

	"go.mongodb.org/mongo-driver/bson/primitive"
	"go.mongodb.org/mongo-driver/mongo"
)

type FakeDatabaseInterface struct {
	CreatTimeEntryByIdStub        func(model.TimeEntry) (interface{}, error)
	creatTimeEntryByIdMutex       sync.RWMutex
	creatTimeEntryByIdArgsForCall []struct {
		arg1 model.TimeEntry
	}
	creatTimeEntryByIdReturns struct {
		result1 interface{}
		result2 error
	}
	creatTimeEntryByIdReturnsOnCall map[int]struct {
		result1 interface{}
		result2 error
	}
	CreateUserStub        func(interface{}) (interface{}, error)
	createUserMutex       sync.RWMutex
	createUserArgsForCall []struct {
		arg1 interface{}
	}
	createUserReturns struct {
		result1 interface{}
		result2 error
	}
	createUserReturnsOnCall map[int]struct {
		result1 interface{}
		result2 error
	}
	DeleteProposalByIdAndDateStub        func(string, string) (*mongo.DeleteResult, error)
	deleteProposalByIdAndDateMutex       sync.RWMutex
	deleteProposalByIdAndDateArgsForCall []struct {
		arg1 string
		arg2 string
	}
	deleteProposalByIdAndDateReturns struct {
		result1 *mongo.DeleteResult
		result2 error
	}
	deleteProposalByIdAndDateReturnsOnCall map[int]struct {
		result1 *mongo.DeleteResult
		result2 error
	}
	DeleteTimeEntryByIdStub        func(string, time.Time) (interface{}, error)
	deleteTimeEntryByIdMutex       sync.RWMutex
	deleteTimeEntryByIdArgsForCall []struct {
		arg1 string
		arg2 time.Time
	}
	deleteTimeEntryByIdReturns struct {
		result1 interface{}
		result2 error
	}
	deleteTimeEntryByIdReturnsOnCall map[int]struct {
		result1 interface{}
		result2 error
	}
	DeleteUserStub        func(primitive.ObjectID) (interface{}, error)
	deleteUserMutex       sync.RWMutex
	deleteUserArgsForCall []struct {
		arg1 primitive.ObjectID
	}
	deleteUserReturns struct {
		result1 interface{}
		result2 error
	}
	deleteUserReturnsOnCall map[int]struct {
		result1 interface{}
		result2 error
	}
	GetAllTimeEntryStub        func() ([]model.TimeEntry, error)
	getAllTimeEntryMutex       sync.RWMutex
	getAllTimeEntryArgsForCall []struct {
	}
	getAllTimeEntryReturns struct {
		result1 []model.TimeEntry
		result2 error
	}
	getAllTimeEntryReturnsOnCall map[int]struct {
		result1 []model.TimeEntry
		result2 error
	}
	GetAllUserStub        func() ([]model.UserPayload, error)
	getAllUserMutex       sync.RWMutex
	getAllUserArgsForCall []struct {
	}
	getAllUserReturns struct {
		result1 []model.UserPayload
		result2 error
	}
	getAllUserReturnsOnCall map[int]struct {
		result1 []model.UserPayload
		result2 error
	}
	GetProposalsByFilterStub        func(primitive.M, primitive.D) ([]model.Proposal, error)
	getProposalsByFilterMutex       sync.RWMutex
	getProposalsByFilterArgsForCall []struct {
		arg1 primitive.M
		arg2 primitive.D
	}
	getProposalsByFilterReturns struct {
		result1 []model.Proposal
		result2 error
	}
	getProposalsByFilterReturnsOnCall map[int]struct {
		result1 []model.Proposal
		result2 error
	}
	GetProposalsByUserIDStub        func(string) ([]model.Proposal, error)
	getProposalsByUserIDMutex       sync.RWMutex
	getProposalsByUserIDArgsForCall []struct {
		arg1 string
	}
	getProposalsByUserIDReturns struct {
		result1 []model.Proposal
		result2 error
	}
	getProposalsByUserIDReturnsOnCall map[int]struct {
		result1 []model.Proposal
		result2 error
	}
	GetTimeEntriesByFilterStub        func(primitive.M) ([]model.TimeEntry, error)
	getTimeEntriesByFilterMutex       sync.RWMutex
	getTimeEntriesByFilterArgsForCall []struct {
		arg1 primitive.M
	}
	getTimeEntriesByFilterReturns struct {
		result1 []model.TimeEntry
		result2 error
	}
	getTimeEntriesByFilterReturnsOnCall map[int]struct {
		result1 []model.TimeEntry
		result2 error
	}
	GetTimeEntryByIDStub        func(string) []model.TimeEntry
	getTimeEntryByIDMutex       sync.RWMutex
	getTimeEntryByIDArgsForCall []struct {
		arg1 string
	}
	getTimeEntryByIDReturns struct {
		result1 []model.TimeEntry
	}
	getTimeEntryByIDReturnsOnCall map[int]struct {
		result1 []model.TimeEntry
	}
	GetUserByIDStub        func(primitive.ObjectID) (model.UserPayload, error)
	getUserByIDMutex       sync.RWMutex
	getUserByIDArgsForCall []struct {
		arg1 primitive.ObjectID
	}
	getUserByIDReturns struct {
		result1 model.UserPayload
		result2 error
	}
	getUserByIDReturnsOnCall map[int]struct {
		result1 model.UserPayload
		result2 error
	}
	GetUserByUsernameStub        func(string) (model.User, error)
	getUserByUsernameMutex       sync.RWMutex
	getUserByUsernameArgsForCall []struct {
		arg1 string
	}
	getUserByUsernameReturns struct {
		result1 model.User
		result2 error
	}
	getUserByUsernameReturnsOnCall map[int]struct {
		result1 model.User
		result2 error
	}
	GetUserTeamMembersByIDStub        func(primitive.ObjectID) (interface{}, error)
	getUserTeamMembersByIDMutex       sync.RWMutex
	getUserTeamMembersByIDArgsForCall []struct {
		arg1 primitive.ObjectID
	}
	getUserTeamMembersByIDReturns struct {
		result1 interface{}
		result2 error
	}
	getUserTeamMembersByIDReturnsOnCall map[int]struct {
		result1 interface{}
		result2 error
	}
	GetUserTeamMembersByNameStub        func(string) (interface{}, error)
	getUserTeamMembersByNameMutex       sync.RWMutex
	getUserTeamMembersByNameArgsForCall []struct {
		arg1 string
	}
	getUserTeamMembersByNameReturns struct {
		result1 interface{}
		result2 error
	}
	getUserTeamMembersByNameReturnsOnCall map[int]struct {
		result1 interface{}
		result2 error
	}
	SaveProposalsStub        func([]interface{}) (interface{}, error)
	saveProposalsMutex       sync.RWMutex
	saveProposalsArgsForCall []struct {
		arg1 []interface{}
	}
	saveProposalsReturns struct {
		result1 interface{}
		result2 error
	}
	saveProposalsReturnsOnCall map[int]struct {
		result1 interface{}
		result2 error
	}
	UpdateProposalStub        func(model.Proposal, string) (*mongo.UpdateResult, error)
	updateProposalMutex       sync.RWMutex
	updateProposalArgsForCall []struct {
		arg1 model.Proposal
		arg2 string
	}
	updateProposalReturns struct {
		result1 *mongo.UpdateResult
		result2 error
	}
	updateProposalReturnsOnCall map[int]struct {
		result1 *mongo.UpdateResult
		result2 error
	}
	UpdateTimeEntryByIdStub        func(model.TimeEntry) (*mongo.UpdateResult, error)
	updateTimeEntryByIdMutex       sync.RWMutex
	updateTimeEntryByIdArgsForCall []struct {
		arg1 model.TimeEntry
	}
	updateTimeEntryByIdReturns struct {
		result1 *mongo.UpdateResult
		result2 error
	}
	updateTimeEntryByIdReturnsOnCall map[int]struct {
		result1 *mongo.UpdateResult
		result2 error
	}
	UpdateUserByIDStub        func(primitive.M, primitive.D) (*mongo.UpdateResult, error)
	updateUserByIDMutex       sync.RWMutex
	updateUserByIDArgsForCall []struct {
		arg1 primitive.M
		arg2 primitive.D
	}
	updateUserByIDReturns struct {
		result1 *mongo.UpdateResult
		result2 error
	}
	updateUserByIDReturnsOnCall map[int]struct {
		result1 *mongo.UpdateResult
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeDatabaseInterface) CreatTimeEntryById(arg1 model.TimeEntry) (interface{}, error) {
	fake.creatTimeEntryByIdMutex.Lock()
	ret, specificReturn := fake.creatTimeEntryByIdReturnsOnCall[len(fake.creatTimeEntryByIdArgsForCall)]
	fake.creatTimeEntryByIdArgsForCall = append(fake.creatTimeEntryByIdArgsForCall, struct {
		arg1 model.TimeEntry
	}{arg1})
	stub := fake.CreatTimeEntryByIdStub
	fakeReturns := fake.creatTimeEntryByIdReturns
	fake.recordInvocation("CreatTimeEntryById", []interface{}{arg1})
	fake.creatTimeEntryByIdMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDatabaseInterface) CreatTimeEntryByIdCallCount() int {
	fake.creatTimeEntryByIdMutex.RLock()
	defer fake.creatTimeEntryByIdMutex.RUnlock()
	return len(fake.creatTimeEntryByIdArgsForCall)
}

func (fake *FakeDatabaseInterface) CreatTimeEntryByIdCalls(stub func(model.TimeEntry) (interface{}, error)) {
	fake.creatTimeEntryByIdMutex.Lock()
	defer fake.creatTimeEntryByIdMutex.Unlock()
	fake.CreatTimeEntryByIdStub = stub
}

func (fake *FakeDatabaseInterface) CreatTimeEntryByIdArgsForCall(i int) model.TimeEntry {
	fake.creatTimeEntryByIdMutex.RLock()
	defer fake.creatTimeEntryByIdMutex.RUnlock()
	argsForCall := fake.creatTimeEntryByIdArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDatabaseInterface) CreatTimeEntryByIdReturns(result1 interface{}, result2 error) {
	fake.creatTimeEntryByIdMutex.Lock()
	defer fake.creatTimeEntryByIdMutex.Unlock()
	fake.CreatTimeEntryByIdStub = nil
	fake.creatTimeEntryByIdReturns = struct {
		result1 interface{}
		result2 error
	}{result1, result2}
}

func (fake *FakeDatabaseInterface) CreatTimeEntryByIdReturnsOnCall(i int, result1 interface{}, result2 error) {
	fake.creatTimeEntryByIdMutex.Lock()
	defer fake.creatTimeEntryByIdMutex.Unlock()
	fake.CreatTimeEntryByIdStub = nil
	if fake.creatTimeEntryByIdReturnsOnCall == nil {
		fake.creatTimeEntryByIdReturnsOnCall = make(map[int]struct {
			result1 interface{}
			result2 error
		})
	}
	fake.creatTimeEntryByIdReturnsOnCall[i] = struct {
		result1 interface{}
		result2 error
	}{result1, result2}
}

func (fake *FakeDatabaseInterface) CreateUser(arg1 interface{}) (interface{}, error) {
	fake.createUserMutex.Lock()
	ret, specificReturn := fake.createUserReturnsOnCall[len(fake.createUserArgsForCall)]
	fake.createUserArgsForCall = append(fake.createUserArgsForCall, struct {
		arg1 interface{}
	}{arg1})
	stub := fake.CreateUserStub
	fakeReturns := fake.createUserReturns
	fake.recordInvocation("CreateUser", []interface{}{arg1})
	fake.createUserMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDatabaseInterface) CreateUserCallCount() int {
	fake.createUserMutex.RLock()
	defer fake.createUserMutex.RUnlock()
	return len(fake.createUserArgsForCall)
}

func (fake *FakeDatabaseInterface) CreateUserCalls(stub func(interface{}) (interface{}, error)) {
	fake.createUserMutex.Lock()
	defer fake.createUserMutex.Unlock()
	fake.CreateUserStub = stub
}

func (fake *FakeDatabaseInterface) CreateUserArgsForCall(i int) interface{} {
	fake.createUserMutex.RLock()
	defer fake.createUserMutex.RUnlock()
	argsForCall := fake.createUserArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDatabaseInterface) CreateUserReturns(result1 interface{}, result2 error) {
	fake.createUserMutex.Lock()
	defer fake.createUserMutex.Unlock()
	fake.CreateUserStub = nil
	fake.createUserReturns = struct {
		result1 interface{}
		result2 error
	}{result1, result2}
}

func (fake *FakeDatabaseInterface) CreateUserReturnsOnCall(i int, result1 interface{}, result2 error) {
	fake.createUserMutex.Lock()
	defer fake.createUserMutex.Unlock()
	fake.CreateUserStub = nil
	if fake.createUserReturnsOnCall == nil {
		fake.createUserReturnsOnCall = make(map[int]struct {
			result1 interface{}
			result2 error
		})
	}
	fake.createUserReturnsOnCall[i] = struct {
		result1 interface{}
		result2 error
	}{result1, result2}
}

func (fake *FakeDatabaseInterface) DeleteProposalByIdAndDate(arg1 string, arg2 string) (*mongo.DeleteResult, error) {
	fake.deleteProposalByIdAndDateMutex.Lock()
	ret, specificReturn := fake.deleteProposalByIdAndDateReturnsOnCall[len(fake.deleteProposalByIdAndDateArgsForCall)]
	fake.deleteProposalByIdAndDateArgsForCall = append(fake.deleteProposalByIdAndDateArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.DeleteProposalByIdAndDateStub
	fakeReturns := fake.deleteProposalByIdAndDateReturns
	fake.recordInvocation("DeleteProposalByIdAndDate", []interface{}{arg1, arg2})
	fake.deleteProposalByIdAndDateMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDatabaseInterface) DeleteProposalByIdAndDateCallCount() int {
	fake.deleteProposalByIdAndDateMutex.RLock()
	defer fake.deleteProposalByIdAndDateMutex.RUnlock()
	return len(fake.deleteProposalByIdAndDateArgsForCall)
}

func (fake *FakeDatabaseInterface) DeleteProposalByIdAndDateCalls(stub func(string, string) (*mongo.DeleteResult, error)) {
	fake.deleteProposalByIdAndDateMutex.Lock()
	defer fake.deleteProposalByIdAndDateMutex.Unlock()
	fake.DeleteProposalByIdAndDateStub = stub
}

func (fake *FakeDatabaseInterface) DeleteProposalByIdAndDateArgsForCall(i int) (string, string) {
	fake.deleteProposalByIdAndDateMutex.RLock()
	defer fake.deleteProposalByIdAndDateMutex.RUnlock()
	argsForCall := fake.deleteProposalByIdAndDateArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeDatabaseInterface) DeleteProposalByIdAndDateReturns(result1 *mongo.DeleteResult, result2 error) {
	fake.deleteProposalByIdAndDateMutex.Lock()
	defer fake.deleteProposalByIdAndDateMutex.Unlock()
	fake.DeleteProposalByIdAndDateStub = nil
	fake.deleteProposalByIdAndDateReturns = struct {
		result1 *mongo.DeleteResult
		result2 error
	}{result1, result2}
}

func (fake *FakeDatabaseInterface) DeleteProposalByIdAndDateReturnsOnCall(i int, result1 *mongo.DeleteResult, result2 error) {
	fake.deleteProposalByIdAndDateMutex.Lock()
	defer fake.deleteProposalByIdAndDateMutex.Unlock()
	fake.DeleteProposalByIdAndDateStub = nil
	if fake.deleteProposalByIdAndDateReturnsOnCall == nil {
		fake.deleteProposalByIdAndDateReturnsOnCall = make(map[int]struct {
			result1 *mongo.DeleteResult
			result2 error
		})
	}
	fake.deleteProposalByIdAndDateReturnsOnCall[i] = struct {
		result1 *mongo.DeleteResult
		result2 error
	}{result1, result2}
}

func (fake *FakeDatabaseInterface) DeleteTimeEntryById(arg1 string, arg2 time.Time) (interface{}, error) {
	fake.deleteTimeEntryByIdMutex.Lock()
	ret, specificReturn := fake.deleteTimeEntryByIdReturnsOnCall[len(fake.deleteTimeEntryByIdArgsForCall)]
	fake.deleteTimeEntryByIdArgsForCall = append(fake.deleteTimeEntryByIdArgsForCall, struct {
		arg1 string
		arg2 time.Time
	}{arg1, arg2})
	stub := fake.DeleteTimeEntryByIdStub
	fakeReturns := fake.deleteTimeEntryByIdReturns
	fake.recordInvocation("DeleteTimeEntryById", []interface{}{arg1, arg2})
	fake.deleteTimeEntryByIdMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDatabaseInterface) DeleteTimeEntryByIdCallCount() int {
	fake.deleteTimeEntryByIdMutex.RLock()
	defer fake.deleteTimeEntryByIdMutex.RUnlock()
	return len(fake.deleteTimeEntryByIdArgsForCall)
}

func (fake *FakeDatabaseInterface) DeleteTimeEntryByIdCalls(stub func(string, time.Time) (interface{}, error)) {
	fake.deleteTimeEntryByIdMutex.Lock()
	defer fake.deleteTimeEntryByIdMutex.Unlock()
	fake.DeleteTimeEntryByIdStub = stub
}

func (fake *FakeDatabaseInterface) DeleteTimeEntryByIdArgsForCall(i int) (string, time.Time) {
	fake.deleteTimeEntryByIdMutex.RLock()
	defer fake.deleteTimeEntryByIdMutex.RUnlock()
	argsForCall := fake.deleteTimeEntryByIdArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeDatabaseInterface) DeleteTimeEntryByIdReturns(result1 interface{}, result2 error) {
	fake.deleteTimeEntryByIdMutex.Lock()
	defer fake.deleteTimeEntryByIdMutex.Unlock()
	fake.DeleteTimeEntryByIdStub = nil
	fake.deleteTimeEntryByIdReturns = struct {
		result1 interface{}
		result2 error
	}{result1, result2}
}

func (fake *FakeDatabaseInterface) DeleteTimeEntryByIdReturnsOnCall(i int, result1 interface{}, result2 error) {
	fake.deleteTimeEntryByIdMutex.Lock()
	defer fake.deleteTimeEntryByIdMutex.Unlock()
	fake.DeleteTimeEntryByIdStub = nil
	if fake.deleteTimeEntryByIdReturnsOnCall == nil {
		fake.deleteTimeEntryByIdReturnsOnCall = make(map[int]struct {
			result1 interface{}
			result2 error
		})
	}
	fake.deleteTimeEntryByIdReturnsOnCall[i] = struct {
		result1 interface{}
		result2 error
	}{result1, result2}
}

func (fake *FakeDatabaseInterface) DeleteUser(arg1 primitive.ObjectID) (interface{}, error) {
	fake.deleteUserMutex.Lock()
	ret, specificReturn := fake.deleteUserReturnsOnCall[len(fake.deleteUserArgsForCall)]
	fake.deleteUserArgsForCall = append(fake.deleteUserArgsForCall, struct {
		arg1 primitive.ObjectID
	}{arg1})
	stub := fake.DeleteUserStub
	fakeReturns := fake.deleteUserReturns
	fake.recordInvocation("DeleteUser", []interface{}{arg1})
	fake.deleteUserMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDatabaseInterface) DeleteUserCallCount() int {
	fake.deleteUserMutex.RLock()
	defer fake.deleteUserMutex.RUnlock()
	return len(fake.deleteUserArgsForCall)
}

func (fake *FakeDatabaseInterface) DeleteUserCalls(stub func(primitive.ObjectID) (interface{}, error)) {
	fake.deleteUserMutex.Lock()
	defer fake.deleteUserMutex.Unlock()
	fake.DeleteUserStub = stub
}

func (fake *FakeDatabaseInterface) DeleteUserArgsForCall(i int) primitive.ObjectID {
	fake.deleteUserMutex.RLock()
	defer fake.deleteUserMutex.RUnlock()
	argsForCall := fake.deleteUserArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDatabaseInterface) DeleteUserReturns(result1 interface{}, result2 error) {
	fake.deleteUserMutex.Lock()
	defer fake.deleteUserMutex.Unlock()
	fake.DeleteUserStub = nil
	fake.deleteUserReturns = struct {
		result1 interface{}
		result2 error
	}{result1, result2}
}

func (fake *FakeDatabaseInterface) DeleteUserReturnsOnCall(i int, result1 interface{}, result2 error) {
	fake.deleteUserMutex.Lock()
	defer fake.deleteUserMutex.Unlock()
	fake.DeleteUserStub = nil
	if fake.deleteUserReturnsOnCall == nil {
		fake.deleteUserReturnsOnCall = make(map[int]struct {
			result1 interface{}
			result2 error
		})
	}
	fake.deleteUserReturnsOnCall[i] = struct {
		result1 interface{}
		result2 error
	}{result1, result2}
}

func (fake *FakeDatabaseInterface) GetAllTimeEntry() ([]model.TimeEntry, error) {
	fake.getAllTimeEntryMutex.Lock()
	ret, specificReturn := fake.getAllTimeEntryReturnsOnCall[len(fake.getAllTimeEntryArgsForCall)]
	fake.getAllTimeEntryArgsForCall = append(fake.getAllTimeEntryArgsForCall, struct {
	}{})
	stub := fake.GetAllTimeEntryStub
	fakeReturns := fake.getAllTimeEntryReturns
	fake.recordInvocation("GetAllTimeEntry", []interface{}{})
	fake.getAllTimeEntryMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDatabaseInterface) GetAllTimeEntryCallCount() int {
	fake.getAllTimeEntryMutex.RLock()
	defer fake.getAllTimeEntryMutex.RUnlock()
	return len(fake.getAllTimeEntryArgsForCall)
}

func (fake *FakeDatabaseInterface) GetAllTimeEntryCalls(stub func() ([]model.TimeEntry, error)) {
	fake.getAllTimeEntryMutex.Lock()
	defer fake.getAllTimeEntryMutex.Unlock()
	fake.GetAllTimeEntryStub = stub
}

func (fake *FakeDatabaseInterface) GetAllTimeEntryReturns(result1 []model.TimeEntry, result2 error) {
	fake.getAllTimeEntryMutex.Lock()
	defer fake.getAllTimeEntryMutex.Unlock()
	fake.GetAllTimeEntryStub = nil
	fake.getAllTimeEntryReturns = struct {
		result1 []model.TimeEntry
		result2 error
	}{result1, result2}
}

func (fake *FakeDatabaseInterface) GetAllTimeEntryReturnsOnCall(i int, result1 []model.TimeEntry, result2 error) {
	fake.getAllTimeEntryMutex.Lock()
	defer fake.getAllTimeEntryMutex.Unlock()
	fake.GetAllTimeEntryStub = nil
	if fake.getAllTimeEntryReturnsOnCall == nil {
		fake.getAllTimeEntryReturnsOnCall = make(map[int]struct {
			result1 []model.TimeEntry
			result2 error
		})
	}
	fake.getAllTimeEntryReturnsOnCall[i] = struct {
		result1 []model.TimeEntry
		result2 error
	}{result1, result2}
}

func (fake *FakeDatabaseInterface) GetAllUser() ([]model.UserPayload, error) {
	fake.getAllUserMutex.Lock()
	ret, specificReturn := fake.getAllUserReturnsOnCall[len(fake.getAllUserArgsForCall)]
	fake.getAllUserArgsForCall = append(fake.getAllUserArgsForCall, struct {
	}{})
	stub := fake.GetAllUserStub
	fakeReturns := fake.getAllUserReturns
	fake.recordInvocation("GetAllUser", []interface{}{})
	fake.getAllUserMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDatabaseInterface) GetAllUserCallCount() int {
	fake.getAllUserMutex.RLock()
	defer fake.getAllUserMutex.RUnlock()
	return len(fake.getAllUserArgsForCall)
}

func (fake *FakeDatabaseInterface) GetAllUserCalls(stub func() ([]model.UserPayload, error)) {
	fake.getAllUserMutex.Lock()
	defer fake.getAllUserMutex.Unlock()
	fake.GetAllUserStub = stub
}

func (fake *FakeDatabaseInterface) GetAllUserReturns(result1 []model.UserPayload, result2 error) {
	fake.getAllUserMutex.Lock()
	defer fake.getAllUserMutex.Unlock()
	fake.GetAllUserStub = nil
	fake.getAllUserReturns = struct {
		result1 []model.UserPayload
		result2 error
	}{result1, result2}
}

func (fake *FakeDatabaseInterface) GetAllUserReturnsOnCall(i int, result1 []model.UserPayload, result2 error) {
	fake.getAllUserMutex.Lock()
	defer fake.getAllUserMutex.Unlock()
	fake.GetAllUserStub = nil
	if fake.getAllUserReturnsOnCall == nil {
		fake.getAllUserReturnsOnCall = make(map[int]struct {
			result1 []model.UserPayload
			result2 error
		})
	}
	fake.getAllUserReturnsOnCall[i] = struct {
		result1 []model.UserPayload
		result2 error
	}{result1, result2}
}

func (fake *FakeDatabaseInterface) GetProposalsByFilter(arg1 primitive.M, arg2 primitive.D) ([]model.Proposal, error) {
	fake.getProposalsByFilterMutex.Lock()
	ret, specificReturn := fake.getProposalsByFilterReturnsOnCall[len(fake.getProposalsByFilterArgsForCall)]
	fake.getProposalsByFilterArgsForCall = append(fake.getProposalsByFilterArgsForCall, struct {
		arg1 primitive.M
		arg2 primitive.D
	}{arg1, arg2})
	stub := fake.GetProposalsByFilterStub
	fakeReturns := fake.getProposalsByFilterReturns
	fake.recordInvocation("GetProposalsByFilter", []interface{}{arg1, arg2})
	fake.getProposalsByFilterMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDatabaseInterface) GetProposalsByFilterCallCount() int {
	fake.getProposalsByFilterMutex.RLock()
	defer fake.getProposalsByFilterMutex.RUnlock()
	return len(fake.getProposalsByFilterArgsForCall)
}

func (fake *FakeDatabaseInterface) GetProposalsByFilterCalls(stub func(primitive.M, primitive.D) ([]model.Proposal, error)) {
	fake.getProposalsByFilterMutex.Lock()
	defer fake.getProposalsByFilterMutex.Unlock()
	fake.GetProposalsByFilterStub = stub
}

func (fake *FakeDatabaseInterface) GetProposalsByFilterArgsForCall(i int) (primitive.M, primitive.D) {
	fake.getProposalsByFilterMutex.RLock()
	defer fake.getProposalsByFilterMutex.RUnlock()
	argsForCall := fake.getProposalsByFilterArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeDatabaseInterface) GetProposalsByFilterReturns(result1 []model.Proposal, result2 error) {
	fake.getProposalsByFilterMutex.Lock()
	defer fake.getProposalsByFilterMutex.Unlock()
	fake.GetProposalsByFilterStub = nil
	fake.getProposalsByFilterReturns = struct {
		result1 []model.Proposal
		result2 error
	}{result1, result2}
}

func (fake *FakeDatabaseInterface) GetProposalsByFilterReturnsOnCall(i int, result1 []model.Proposal, result2 error) {
	fake.getProposalsByFilterMutex.Lock()
	defer fake.getProposalsByFilterMutex.Unlock()
	fake.GetProposalsByFilterStub = nil
	if fake.getProposalsByFilterReturnsOnCall == nil {
		fake.getProposalsByFilterReturnsOnCall = make(map[int]struct {
			result1 []model.Proposal
			result2 error
		})
	}
	fake.getProposalsByFilterReturnsOnCall[i] = struct {
		result1 []model.Proposal
		result2 error
	}{result1, result2}
}

func (fake *FakeDatabaseInterface) GetProposalsByUserID(arg1 string) ([]model.Proposal, error) {
	fake.getProposalsByUserIDMutex.Lock()
	ret, specificReturn := fake.getProposalsByUserIDReturnsOnCall[len(fake.getProposalsByUserIDArgsForCall)]
	fake.getProposalsByUserIDArgsForCall = append(fake.getProposalsByUserIDArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.GetProposalsByUserIDStub
	fakeReturns := fake.getProposalsByUserIDReturns
	fake.recordInvocation("GetProposalsByUserID", []interface{}{arg1})
	fake.getProposalsByUserIDMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDatabaseInterface) GetProposalsByUserIDCallCount() int {
	fake.getProposalsByUserIDMutex.RLock()
	defer fake.getProposalsByUserIDMutex.RUnlock()
	return len(fake.getProposalsByUserIDArgsForCall)
}

func (fake *FakeDatabaseInterface) GetProposalsByUserIDCalls(stub func(string) ([]model.Proposal, error)) {
	fake.getProposalsByUserIDMutex.Lock()
	defer fake.getProposalsByUserIDMutex.Unlock()
	fake.GetProposalsByUserIDStub = stub
}

func (fake *FakeDatabaseInterface) GetProposalsByUserIDArgsForCall(i int) string {
	fake.getProposalsByUserIDMutex.RLock()
	defer fake.getProposalsByUserIDMutex.RUnlock()
	argsForCall := fake.getProposalsByUserIDArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDatabaseInterface) GetProposalsByUserIDReturns(result1 []model.Proposal, result2 error) {
	fake.getProposalsByUserIDMutex.Lock()
	defer fake.getProposalsByUserIDMutex.Unlock()
	fake.GetProposalsByUserIDStub = nil
	fake.getProposalsByUserIDReturns = struct {
		result1 []model.Proposal
		result2 error
	}{result1, result2}
}

func (fake *FakeDatabaseInterface) GetProposalsByUserIDReturnsOnCall(i int, result1 []model.Proposal, result2 error) {
	fake.getProposalsByUserIDMutex.Lock()
	defer fake.getProposalsByUserIDMutex.Unlock()
	fake.GetProposalsByUserIDStub = nil
	if fake.getProposalsByUserIDReturnsOnCall == nil {
		fake.getProposalsByUserIDReturnsOnCall = make(map[int]struct {
			result1 []model.Proposal
			result2 error
		})
	}
	fake.getProposalsByUserIDReturnsOnCall[i] = struct {
		result1 []model.Proposal
		result2 error
	}{result1, result2}
}

func (fake *FakeDatabaseInterface) GetTimeEntriesByFilter(arg1 primitive.M) ([]model.TimeEntry, error) {
	fake.getTimeEntriesByFilterMutex.Lock()
	ret, specificReturn := fake.getTimeEntriesByFilterReturnsOnCall[len(fake.getTimeEntriesByFilterArgsForCall)]
	fake.getTimeEntriesByFilterArgsForCall = append(fake.getTimeEntriesByFilterArgsForCall, struct {
		arg1 primitive.M
	}{arg1})
	stub := fake.GetTimeEntriesByFilterStub
	fakeReturns := fake.getTimeEntriesByFilterReturns
	fake.recordInvocation("GetTimeEntriesByFilter", []interface{}{arg1})
	fake.getTimeEntriesByFilterMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDatabaseInterface) GetTimeEntriesByFilterCallCount() int {
	fake.getTimeEntriesByFilterMutex.RLock()
	defer fake.getTimeEntriesByFilterMutex.RUnlock()
	return len(fake.getTimeEntriesByFilterArgsForCall)
}

func (fake *FakeDatabaseInterface) GetTimeEntriesByFilterCalls(stub func(primitive.M) ([]model.TimeEntry, error)) {
	fake.getTimeEntriesByFilterMutex.Lock()
	defer fake.getTimeEntriesByFilterMutex.Unlock()
	fake.GetTimeEntriesByFilterStub = stub
}

func (fake *FakeDatabaseInterface) GetTimeEntriesByFilterArgsForCall(i int) primitive.M {
	fake.getTimeEntriesByFilterMutex.RLock()
	defer fake.getTimeEntriesByFilterMutex.RUnlock()
	argsForCall := fake.getTimeEntriesByFilterArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDatabaseInterface) GetTimeEntriesByFilterReturns(result1 []model.TimeEntry, result2 error) {
	fake.getTimeEntriesByFilterMutex.Lock()
	defer fake.getTimeEntriesByFilterMutex.Unlock()
	fake.GetTimeEntriesByFilterStub = nil
	fake.getTimeEntriesByFilterReturns = struct {
		result1 []model.TimeEntry
		result2 error
	}{result1, result2}
}

func (fake *FakeDatabaseInterface) GetTimeEntriesByFilterReturnsOnCall(i int, result1 []model.TimeEntry, result2 error) {
	fake.getTimeEntriesByFilterMutex.Lock()
	defer fake.getTimeEntriesByFilterMutex.Unlock()
	fake.GetTimeEntriesByFilterStub = nil
	if fake.getTimeEntriesByFilterReturnsOnCall == nil {
		fake.getTimeEntriesByFilterReturnsOnCall = make(map[int]struct {
			result1 []model.TimeEntry
			result2 error
		})
	}
	fake.getTimeEntriesByFilterReturnsOnCall[i] = struct {
		result1 []model.TimeEntry
		result2 error
	}{result1, result2}
}

func (fake *FakeDatabaseInterface) GetTimeEntryByID(arg1 string) []model.TimeEntry {
	fake.getTimeEntryByIDMutex.Lock()
	ret, specificReturn := fake.getTimeEntryByIDReturnsOnCall[len(fake.getTimeEntryByIDArgsForCall)]
	fake.getTimeEntryByIDArgsForCall = append(fake.getTimeEntryByIDArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.GetTimeEntryByIDStub
	fakeReturns := fake.getTimeEntryByIDReturns
	fake.recordInvocation("GetTimeEntryByID", []interface{}{arg1})
	fake.getTimeEntryByIDMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeDatabaseInterface) GetTimeEntryByIDCallCount() int {
	fake.getTimeEntryByIDMutex.RLock()
	defer fake.getTimeEntryByIDMutex.RUnlock()
	return len(fake.getTimeEntryByIDArgsForCall)
}

func (fake *FakeDatabaseInterface) GetTimeEntryByIDCalls(stub func(string) []model.TimeEntry) {
	fake.getTimeEntryByIDMutex.Lock()
	defer fake.getTimeEntryByIDMutex.Unlock()
	fake.GetTimeEntryByIDStub = stub
}

func (fake *FakeDatabaseInterface) GetTimeEntryByIDArgsForCall(i int) string {
	fake.getTimeEntryByIDMutex.RLock()
	defer fake.getTimeEntryByIDMutex.RUnlock()
	argsForCall := fake.getTimeEntryByIDArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDatabaseInterface) GetTimeEntryByIDReturns(result1 []model.TimeEntry) {
	fake.getTimeEntryByIDMutex.Lock()
	defer fake.getTimeEntryByIDMutex.Unlock()
	fake.GetTimeEntryByIDStub = nil
	fake.getTimeEntryByIDReturns = struct {
		result1 []model.TimeEntry
	}{result1}
}

func (fake *FakeDatabaseInterface) GetTimeEntryByIDReturnsOnCall(i int, result1 []model.TimeEntry) {
	fake.getTimeEntryByIDMutex.Lock()
	defer fake.getTimeEntryByIDMutex.Unlock()
	fake.GetTimeEntryByIDStub = nil
	if fake.getTimeEntryByIDReturnsOnCall == nil {
		fake.getTimeEntryByIDReturnsOnCall = make(map[int]struct {
			result1 []model.TimeEntry
		})
	}
	fake.getTimeEntryByIDReturnsOnCall[i] = struct {
		result1 []model.TimeEntry
	}{result1}
}

func (fake *FakeDatabaseInterface) GetUserByID(arg1 primitive.ObjectID) (model.UserPayload, error) {
	fake.getUserByIDMutex.Lock()
	ret, specificReturn := fake.getUserByIDReturnsOnCall[len(fake.getUserByIDArgsForCall)]
	fake.getUserByIDArgsForCall = append(fake.getUserByIDArgsForCall, struct {
		arg1 primitive.ObjectID
	}{arg1})
	stub := fake.GetUserByIDStub
	fakeReturns := fake.getUserByIDReturns
	fake.recordInvocation("GetUserByID", []interface{}{arg1})
	fake.getUserByIDMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDatabaseInterface) GetUserByIDCallCount() int {
	fake.getUserByIDMutex.RLock()
	defer fake.getUserByIDMutex.RUnlock()
	return len(fake.getUserByIDArgsForCall)
}

func (fake *FakeDatabaseInterface) GetUserByIDCalls(stub func(primitive.ObjectID) (model.UserPayload, error)) {
	fake.getUserByIDMutex.Lock()
	defer fake.getUserByIDMutex.Unlock()
	fake.GetUserByIDStub = stub
}

func (fake *FakeDatabaseInterface) GetUserByIDArgsForCall(i int) primitive.ObjectID {
	fake.getUserByIDMutex.RLock()
	defer fake.getUserByIDMutex.RUnlock()
	argsForCall := fake.getUserByIDArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDatabaseInterface) GetUserByIDReturns(result1 model.UserPayload, result2 error) {
	fake.getUserByIDMutex.Lock()
	defer fake.getUserByIDMutex.Unlock()
	fake.GetUserByIDStub = nil
	fake.getUserByIDReturns = struct {
		result1 model.UserPayload
		result2 error
	}{result1, result2}
}

func (fake *FakeDatabaseInterface) GetUserByIDReturnsOnCall(i int, result1 model.UserPayload, result2 error) {
	fake.getUserByIDMutex.Lock()
	defer fake.getUserByIDMutex.Unlock()
	fake.GetUserByIDStub = nil
	if fake.getUserByIDReturnsOnCall == nil {
		fake.getUserByIDReturnsOnCall = make(map[int]struct {
			result1 model.UserPayload
			result2 error
		})
	}
	fake.getUserByIDReturnsOnCall[i] = struct {
		result1 model.UserPayload
		result2 error
	}{result1, result2}
}

func (fake *FakeDatabaseInterface) GetUserByUsername(arg1 string) (model.User, error) {
	fake.getUserByUsernameMutex.Lock()
	ret, specificReturn := fake.getUserByUsernameReturnsOnCall[len(fake.getUserByUsernameArgsForCall)]
	fake.getUserByUsernameArgsForCall = append(fake.getUserByUsernameArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.GetUserByUsernameStub
	fakeReturns := fake.getUserByUsernameReturns
	fake.recordInvocation("GetUserByUsername", []interface{}{arg1})
	fake.getUserByUsernameMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDatabaseInterface) GetUserByUsernameCallCount() int {
	fake.getUserByUsernameMutex.RLock()
	defer fake.getUserByUsernameMutex.RUnlock()
	return len(fake.getUserByUsernameArgsForCall)
}

func (fake *FakeDatabaseInterface) GetUserByUsernameCalls(stub func(string) (model.User, error)) {
	fake.getUserByUsernameMutex.Lock()
	defer fake.getUserByUsernameMutex.Unlock()
	fake.GetUserByUsernameStub = stub
}

func (fake *FakeDatabaseInterface) GetUserByUsernameArgsForCall(i int) string {
	fake.getUserByUsernameMutex.RLock()
	defer fake.getUserByUsernameMutex.RUnlock()
	argsForCall := fake.getUserByUsernameArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDatabaseInterface) GetUserByUsernameReturns(result1 model.User, result2 error) {
	fake.getUserByUsernameMutex.Lock()
	defer fake.getUserByUsernameMutex.Unlock()
	fake.GetUserByUsernameStub = nil
	fake.getUserByUsernameReturns = struct {
		result1 model.User
		result2 error
	}{result1, result2}
}

func (fake *FakeDatabaseInterface) GetUserByUsernameReturnsOnCall(i int, result1 model.User, result2 error) {
	fake.getUserByUsernameMutex.Lock()
	defer fake.getUserByUsernameMutex.Unlock()
	fake.GetUserByUsernameStub = nil
	if fake.getUserByUsernameReturnsOnCall == nil {
		fake.getUserByUsernameReturnsOnCall = make(map[int]struct {
			result1 model.User
			result2 error
		})
	}
	fake.getUserByUsernameReturnsOnCall[i] = struct {
		result1 model.User
		result2 error
	}{result1, result2}
}

func (fake *FakeDatabaseInterface) GetUserTeamMembersByID(arg1 primitive.ObjectID) (interface{}, error) {
	fake.getUserTeamMembersByIDMutex.Lock()
	ret, specificReturn := fake.getUserTeamMembersByIDReturnsOnCall[len(fake.getUserTeamMembersByIDArgsForCall)]
	fake.getUserTeamMembersByIDArgsForCall = append(fake.getUserTeamMembersByIDArgsForCall, struct {
		arg1 primitive.ObjectID
	}{arg1})
	stub := fake.GetUserTeamMembersByIDStub
	fakeReturns := fake.getUserTeamMembersByIDReturns
	fake.recordInvocation("GetUserTeamMembersByID", []interface{}{arg1})
	fake.getUserTeamMembersByIDMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDatabaseInterface) GetUserTeamMembersByIDCallCount() int {
	fake.getUserTeamMembersByIDMutex.RLock()
	defer fake.getUserTeamMembersByIDMutex.RUnlock()
	return len(fake.getUserTeamMembersByIDArgsForCall)
}

func (fake *FakeDatabaseInterface) GetUserTeamMembersByIDCalls(stub func(primitive.ObjectID) (interface{}, error)) {
	fake.getUserTeamMembersByIDMutex.Lock()
	defer fake.getUserTeamMembersByIDMutex.Unlock()
	fake.GetUserTeamMembersByIDStub = stub
}

func (fake *FakeDatabaseInterface) GetUserTeamMembersByIDArgsForCall(i int) primitive.ObjectID {
	fake.getUserTeamMembersByIDMutex.RLock()
	defer fake.getUserTeamMembersByIDMutex.RUnlock()
	argsForCall := fake.getUserTeamMembersByIDArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDatabaseInterface) GetUserTeamMembersByIDReturns(result1 interface{}, result2 error) {
	fake.getUserTeamMembersByIDMutex.Lock()
	defer fake.getUserTeamMembersByIDMutex.Unlock()
	fake.GetUserTeamMembersByIDStub = nil
	fake.getUserTeamMembersByIDReturns = struct {
		result1 interface{}
		result2 error
	}{result1, result2}
}

func (fake *FakeDatabaseInterface) GetUserTeamMembersByIDReturnsOnCall(i int, result1 interface{}, result2 error) {
	fake.getUserTeamMembersByIDMutex.Lock()
	defer fake.getUserTeamMembersByIDMutex.Unlock()
	fake.GetUserTeamMembersByIDStub = nil
	if fake.getUserTeamMembersByIDReturnsOnCall == nil {
		fake.getUserTeamMembersByIDReturnsOnCall = make(map[int]struct {
			result1 interface{}
			result2 error
		})
	}
	fake.getUserTeamMembersByIDReturnsOnCall[i] = struct {
		result1 interface{}
		result2 error
	}{result1, result2}
}

func (fake *FakeDatabaseInterface) GetUserTeamMembersByName(arg1 string) (interface{}, error) {
	fake.getUserTeamMembersByNameMutex.Lock()
	ret, specificReturn := fake.getUserTeamMembersByNameReturnsOnCall[len(fake.getUserTeamMembersByNameArgsForCall)]
	fake.getUserTeamMembersByNameArgsForCall = append(fake.getUserTeamMembersByNameArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.GetUserTeamMembersByNameStub
	fakeReturns := fake.getUserTeamMembersByNameReturns
	fake.recordInvocation("GetUserTeamMembersByName", []interface{}{arg1})
	fake.getUserTeamMembersByNameMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDatabaseInterface) GetUserTeamMembersByNameCallCount() int {
	fake.getUserTeamMembersByNameMutex.RLock()
	defer fake.getUserTeamMembersByNameMutex.RUnlock()
	return len(fake.getUserTeamMembersByNameArgsForCall)
}

func (fake *FakeDatabaseInterface) GetUserTeamMembersByNameCalls(stub func(string) (interface{}, error)) {
	fake.getUserTeamMembersByNameMutex.Lock()
	defer fake.getUserTeamMembersByNameMutex.Unlock()
	fake.GetUserTeamMembersByNameStub = stub
}

func (fake *FakeDatabaseInterface) GetUserTeamMembersByNameArgsForCall(i int) string {
	fake.getUserTeamMembersByNameMutex.RLock()
	defer fake.getUserTeamMembersByNameMutex.RUnlock()
	argsForCall := fake.getUserTeamMembersByNameArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDatabaseInterface) GetUserTeamMembersByNameReturns(result1 interface{}, result2 error) {
	fake.getUserTeamMembersByNameMutex.Lock()
	defer fake.getUserTeamMembersByNameMutex.Unlock()
	fake.GetUserTeamMembersByNameStub = nil
	fake.getUserTeamMembersByNameReturns = struct {
		result1 interface{}
		result2 error
	}{result1, result2}
}

func (fake *FakeDatabaseInterface) GetUserTeamMembersByNameReturnsOnCall(i int, result1 interface{}, result2 error) {
	fake.getUserTeamMembersByNameMutex.Lock()
	defer fake.getUserTeamMembersByNameMutex.Unlock()
	fake.GetUserTeamMembersByNameStub = nil
	if fake.getUserTeamMembersByNameReturnsOnCall == nil {
		fake.getUserTeamMembersByNameReturnsOnCall = make(map[int]struct {
			result1 interface{}
			result2 error
		})
	}
	fake.getUserTeamMembersByNameReturnsOnCall[i] = struct {
		result1 interface{}
		result2 error
	}{result1, result2}
}

func (fake *FakeDatabaseInterface) SaveProposals(arg1 []interface{}) (interface{}, error) {
	var arg1Copy []interface{}
	if arg1 != nil {
		arg1Copy = make([]interface{}, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.saveProposalsMutex.Lock()
	ret, specificReturn := fake.saveProposalsReturnsOnCall[len(fake.saveProposalsArgsForCall)]
	fake.saveProposalsArgsForCall = append(fake.saveProposalsArgsForCall, struct {
		arg1 []interface{}
	}{arg1Copy})
	stub := fake.SaveProposalsStub
	fakeReturns := fake.saveProposalsReturns
	fake.recordInvocation("SaveProposals", []interface{}{arg1Copy})
	fake.saveProposalsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDatabaseInterface) SaveProposalsCallCount() int {
	fake.saveProposalsMutex.RLock()
	defer fake.saveProposalsMutex.RUnlock()
	return len(fake.saveProposalsArgsForCall)
}

func (fake *FakeDatabaseInterface) SaveProposalsCalls(stub func([]interface{}) (interface{}, error)) {
	fake.saveProposalsMutex.Lock()
	defer fake.saveProposalsMutex.Unlock()
	fake.SaveProposalsStub = stub
}

func (fake *FakeDatabaseInterface) SaveProposalsArgsForCall(i int) []interface{} {
	fake.saveProposalsMutex.RLock()
	defer fake.saveProposalsMutex.RUnlock()
	argsForCall := fake.saveProposalsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDatabaseInterface) SaveProposalsReturns(result1 interface{}, result2 error) {
	fake.saveProposalsMutex.Lock()
	defer fake.saveProposalsMutex.Unlock()
	fake.SaveProposalsStub = nil
	fake.saveProposalsReturns = struct {
		result1 interface{}
		result2 error
	}{result1, result2}
}

func (fake *FakeDatabaseInterface) SaveProposalsReturnsOnCall(i int, result1 interface{}, result2 error) {
	fake.saveProposalsMutex.Lock()
	defer fake.saveProposalsMutex.Unlock()
	fake.SaveProposalsStub = nil
	if fake.saveProposalsReturnsOnCall == nil {
		fake.saveProposalsReturnsOnCall = make(map[int]struct {
			result1 interface{}
			result2 error
		})
	}
	fake.saveProposalsReturnsOnCall[i] = struct {
		result1 interface{}
		result2 error
	}{result1, result2}
}

func (fake *FakeDatabaseInterface) UpdateProposal(arg1 model.Proposal, arg2 string) (*mongo.UpdateResult, error) {
	fake.updateProposalMutex.Lock()
	ret, specificReturn := fake.updateProposalReturnsOnCall[len(fake.updateProposalArgsForCall)]
	fake.updateProposalArgsForCall = append(fake.updateProposalArgsForCall, struct {
		arg1 model.Proposal
		arg2 string
	}{arg1, arg2})
	stub := fake.UpdateProposalStub
	fakeReturns := fake.updateProposalReturns
	fake.recordInvocation("UpdateProposal", []interface{}{arg1, arg2})
	fake.updateProposalMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDatabaseInterface) UpdateProposalCallCount() int {
	fake.updateProposalMutex.RLock()
	defer fake.updateProposalMutex.RUnlock()
	return len(fake.updateProposalArgsForCall)
}

func (fake *FakeDatabaseInterface) UpdateProposalCalls(stub func(model.Proposal, string) (*mongo.UpdateResult, error)) {
	fake.updateProposalMutex.Lock()
	defer fake.updateProposalMutex.Unlock()
	fake.UpdateProposalStub = stub
}

func (fake *FakeDatabaseInterface) UpdateProposalArgsForCall(i int) (model.Proposal, string) {
	fake.updateProposalMutex.RLock()
	defer fake.updateProposalMutex.RUnlock()
	argsForCall := fake.updateProposalArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeDatabaseInterface) UpdateProposalReturns(result1 *mongo.UpdateResult, result2 error) {
	fake.updateProposalMutex.Lock()
	defer fake.updateProposalMutex.Unlock()
	fake.UpdateProposalStub = nil
	fake.updateProposalReturns = struct {
		result1 *mongo.UpdateResult
		result2 error
	}{result1, result2}
}

func (fake *FakeDatabaseInterface) UpdateProposalReturnsOnCall(i int, result1 *mongo.UpdateResult, result2 error) {
	fake.updateProposalMutex.Lock()
	defer fake.updateProposalMutex.Unlock()
	fake.UpdateProposalStub = nil
	if fake.updateProposalReturnsOnCall == nil {
		fake.updateProposalReturnsOnCall = make(map[int]struct {
			result1 *mongo.UpdateResult
			result2 error
		})
	}
	fake.updateProposalReturnsOnCall[i] = struct {
		result1 *mongo.UpdateResult
		result2 error
	}{result1, result2}
}

func (fake *FakeDatabaseInterface) UpdateTimeEntryById(arg1 model.TimeEntry) (*mongo.UpdateResult, error) {
	fake.updateTimeEntryByIdMutex.Lock()
	ret, specificReturn := fake.updateTimeEntryByIdReturnsOnCall[len(fake.updateTimeEntryByIdArgsForCall)]
	fake.updateTimeEntryByIdArgsForCall = append(fake.updateTimeEntryByIdArgsForCall, struct {
		arg1 model.TimeEntry
	}{arg1})
	stub := fake.UpdateTimeEntryByIdStub
	fakeReturns := fake.updateTimeEntryByIdReturns
	fake.recordInvocation("UpdateTimeEntryById", []interface{}{arg1})
	fake.updateTimeEntryByIdMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDatabaseInterface) UpdateTimeEntryByIdCallCount() int {
	fake.updateTimeEntryByIdMutex.RLock()
	defer fake.updateTimeEntryByIdMutex.RUnlock()
	return len(fake.updateTimeEntryByIdArgsForCall)
}

func (fake *FakeDatabaseInterface) UpdateTimeEntryByIdCalls(stub func(model.TimeEntry) (*mongo.UpdateResult, error)) {
	fake.updateTimeEntryByIdMutex.Lock()
	defer fake.updateTimeEntryByIdMutex.Unlock()
	fake.UpdateTimeEntryByIdStub = stub
}

func (fake *FakeDatabaseInterface) UpdateTimeEntryByIdArgsForCall(i int) model.TimeEntry {
	fake.updateTimeEntryByIdMutex.RLock()
	defer fake.updateTimeEntryByIdMutex.RUnlock()
	argsForCall := fake.updateTimeEntryByIdArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDatabaseInterface) UpdateTimeEntryByIdReturns(result1 *mongo.UpdateResult, result2 error) {
	fake.updateTimeEntryByIdMutex.Lock()
	defer fake.updateTimeEntryByIdMutex.Unlock()
	fake.UpdateTimeEntryByIdStub = nil
	fake.updateTimeEntryByIdReturns = struct {
		result1 *mongo.UpdateResult
		result2 error
	}{result1, result2}
}

func (fake *FakeDatabaseInterface) UpdateTimeEntryByIdReturnsOnCall(i int, result1 *mongo.UpdateResult, result2 error) {
	fake.updateTimeEntryByIdMutex.Lock()
	defer fake.updateTimeEntryByIdMutex.Unlock()
	fake.UpdateTimeEntryByIdStub = nil
	if fake.updateTimeEntryByIdReturnsOnCall == nil {
		fake.updateTimeEntryByIdReturnsOnCall = make(map[int]struct {
			result1 *mongo.UpdateResult
			result2 error
		})
	}
	fake.updateTimeEntryByIdReturnsOnCall[i] = struct {
		result1 *mongo.UpdateResult
		result2 error
	}{result1, result2}
}

func (fake *FakeDatabaseInterface) UpdateUserByID(arg1 primitive.M, arg2 primitive.D) (*mongo.UpdateResult, error) {
	fake.updateUserByIDMutex.Lock()
	ret, specificReturn := fake.updateUserByIDReturnsOnCall[len(fake.updateUserByIDArgsForCall)]
	fake.updateUserByIDArgsForCall = append(fake.updateUserByIDArgsForCall, struct {
		arg1 primitive.M
		arg2 primitive.D
	}{arg1, arg2})
	stub := fake.UpdateUserByIDStub
	fakeReturns := fake.updateUserByIDReturns
	fake.recordInvocation("UpdateUserByID", []interface{}{arg1, arg2})
	fake.updateUserByIDMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDatabaseInterface) UpdateUserByIDCallCount() int {
	fake.updateUserByIDMutex.RLock()
	defer fake.updateUserByIDMutex.RUnlock()
	return len(fake.updateUserByIDArgsForCall)
}

func (fake *FakeDatabaseInterface) UpdateUserByIDCalls(stub func(primitive.M, primitive.D) (*mongo.UpdateResult, error)) {
	fake.updateUserByIDMutex.Lock()
	defer fake.updateUserByIDMutex.Unlock()
	fake.UpdateUserByIDStub = stub
}

func (fake *FakeDatabaseInterface) UpdateUserByIDArgsForCall(i int) (primitive.M, primitive.D) {
	fake.updateUserByIDMutex.RLock()
	defer fake.updateUserByIDMutex.RUnlock()
	argsForCall := fake.updateUserByIDArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeDatabaseInterface) UpdateUserByIDReturns(result1 *mongo.UpdateResult, result2 error) {
	fake.updateUserByIDMutex.Lock()
	defer fake.updateUserByIDMutex.Unlock()
	fake.UpdateUserByIDStub = nil
	fake.updateUserByIDReturns = struct {
		result1 *mongo.UpdateResult
		result2 error
	}{result1, result2}
}

func (fake *FakeDatabaseInterface) UpdateUserByIDReturnsOnCall(i int, result1 *mongo.UpdateResult, result2 error) {
	fake.updateUserByIDMutex.Lock()
	defer fake.updateUserByIDMutex.Unlock()
	fake.UpdateUserByIDStub = nil
	if fake.updateUserByIDReturnsOnCall == nil {
		fake.updateUserByIDReturnsOnCall = make(map[int]struct {
			result1 *mongo.UpdateResult
			result2 error
		})
	}
	fake.updateUserByIDReturnsOnCall[i] = struct {
		result1 *mongo.UpdateResult
		result2 error
	}{result1, result2}
}

func (fake *FakeDatabaseInterface) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.creatTimeEntryByIdMutex.RLock()
	defer fake.creatTimeEntryByIdMutex.RUnlock()
	fake.createUserMutex.RLock()
	defer fake.createUserMutex.RUnlock()
	fake.deleteProposalByIdAndDateMutex.RLock()
	defer fake.deleteProposalByIdAndDateMutex.RUnlock()
	fake.deleteTimeEntryByIdMutex.RLock()
	defer fake.deleteTimeEntryByIdMutex.RUnlock()
	fake.deleteUserMutex.RLock()
	defer fake.deleteUserMutex.RUnlock()
	fake.getAllTimeEntryMutex.RLock()
	defer fake.getAllTimeEntryMutex.RUnlock()
	fake.getAllUserMutex.RLock()
	defer fake.getAllUserMutex.RUnlock()
	fake.getProposalsByFilterMutex.RLock()
	defer fake.getProposalsByFilterMutex.RUnlock()
	fake.getProposalsByUserIDMutex.RLock()
	defer fake.getProposalsByUserIDMutex.RUnlock()
	fake.getTimeEntriesByFilterMutex.RLock()
	defer fake.getTimeEntriesByFilterMutex.RUnlock()
	fake.getTimeEntryByIDMutex.RLock()
	defer fake.getTimeEntryByIDMutex.RUnlock()
	fake.getUserByIDMutex.RLock()
	defer fake.getUserByIDMutex.RUnlock()
	fake.getUserByUsernameMutex.RLock()
	defer fake.getUserByUsernameMutex.RUnlock()
	fake.getUserTeamMembersByIDMutex.RLock()
	defer fake.getUserTeamMembersByIDMutex.RUnlock()
	fake.getUserTeamMembersByNameMutex.RLock()
	defer fake.getUserTeamMembersByNameMutex.RUnlock()
	fake.saveProposalsMutex.RLock()
	defer fake.saveProposalsMutex.RUnlock()
	fake.updateProposalMutex.RLock()
	defer fake.updateProposalMutex.RUnlock()
	fake.updateTimeEntryByIdMutex.RLock()
	defer fake.updateTimeEntryByIdMutex.RUnlock()
	fake.updateUserByIDMutex.RLock()
	defer fake.updateUserByIDMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeDatabaseInterface) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ service.DatabaseInterface = new(FakeDatabaseInterface)
